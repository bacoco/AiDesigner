#!/usr/bin/env node

/**
 * AiDesigner - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx aidesigner init
 *   npx aidesigner chat
 *   npx aidesigner install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const inquirer = require('inquirer');
const { runIntegrityPreflight } = require('../common/utils/integrity');
const { buildAssistantSpawnEnv } = require('../common/utils/assistant-env');
const { ProjectState } = require('../lib/project-state.js');
const logger = require('../common/utils/logger');

let command;
let args = [];
const packageRoot = path.join(__dirname, '..');

const CLAUDE_PROVIDER_ENV_KEYS = [
  'AGILAI_ASSISTANT_PROVIDER',
  'BMAD_ASSISTANT_PROVIDER',
  'CLAUDE_CLI_PROVIDER',
  'CLAUDE_CLI_DEFAULT_PROVIDER',
  'CLAUDE_DEFAULT_PROVIDER',
  'CLAUDE_PROVIDER',
  'CLAUDE_CODE_PROVIDER',
];

const GLM_API_KEY_ENV_KEYS = ['AGILAI_GLM_API_KEY', 'BMAD_GLM_API_KEY', 'GLM_API_KEY', 'ZHIPUAI_API_KEY'];
const GLM_BASE_URL_ENV_KEYS = ['AGILAI_GLM_BASE_URL', 'BMAD_GLM_BASE_URL', 'GLM_BASE_URL'];
const GLM_AUTH_TOKEN_ENV_KEYS = ['AGILAI_GLM_AUTH_TOKEN', 'BMAD_GLM_AUTH_TOKEN', 'GLM_AUTH_TOKEN'];

const hasOwn = (source, key) => Boolean(source && Object.prototype.hasOwnProperty.call(source, key));

/**
 * Resolves environment variable value from a prioritized list of keys
 * @param {Object} source - Environment object to search (e.g., process.env or parsed .env file)
 * @param {string[]} keys - Array of keys in priority order (first match wins)
 * @returns {{key: string|undefined, value: string|undefined}} The matched key and its trimmed value
 */
const resolveEnvValue = (source, keys) => {
  for (const key of keys) {
    const value = source?.[key];
    if (typeof value === 'string' && value.trim()) {
      return { key, value: value.trim() };
    }
  }

  return { key: undefined, value: undefined };
};

/**
 * Chooses which environment variable key to use for writing
 * Returns the first existing key from the source, or the first key if none exist
 * @param {Object} source - Environment object to check (e.g., parsed .env file)
 * @param {string[]} keys - Array of keys in priority order
 * @returns {string} The key to use for writing
 */
const chooseWriteKey = (source, keys) => {
  for (const key of keys) {
    if (hasOwn(source, key)) {
      return key;
    }
  }

  return keys[0];
};

/**
 * Sets a process environment variable only if it's not already set or is empty/whitespace
 * @param {string} key - The environment variable name
 * @param {string|undefined} value - The value to set (ignored if falsy or whitespace-only)
 */
const setProcessEnvIfMissing = (key, value) => {
  if (!value || (typeof value === 'string' && value.trim() === '')) {
    return;
  }

  if (typeof process.env[key] !== 'string' || process.env[key].trim() === '') {
    process.env[key] = value;
  }
};

const parseEnvFile = (filePath) => {
  const parsed = {};
  const raw = fs.readFileSync(filePath, 'utf8');
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    const equalsIndex = trimmed.indexOf('=');
    if (equalsIndex === -1) {
      continue;
    }

    let key = trimmed.slice(0, equalsIndex).trim();
    if (key.startsWith('export ')) {
      key = key.slice('export '.length).trim();
    }

    if (!key) {
      continue;
    }

    let value = trimmed.slice(equalsIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    // Validate that value doesn't contain newlines (would break .env format)
    if (value.includes('\n') || value.includes('\r')) {
      console.warn(`⚠️ Skipping invalid .env value for ${key}: contains newline characters`);
      continue;
    }

    parsed[key] = value;
  }

  return parsed;
};

const readProjectEnv = (projectRoot) => {
  const envPath = path.join(projectRoot, '.env');
  if (!fs.existsSync(envPath)) {
    return { values: {}, path: envPath };
  }

  try {
    return { values: parseEnvFile(envPath), path: envPath };
  } catch (error) {
    logger.warn('Unable to parse .env file, continuing without it', {
      component: 'CLI',
      envPath,
      error: error.message || String(error),
    });
    return { values: {}, path: envPath };
  }
};

const isInteractiveTerminal = () => Boolean(process.stdin.isTTY && process.stdout.isTTY);

/**
 * Parses provider from CLI arguments.
 * Precedence: CLI args > process env vars > .env file > interactive prompts
 */
const parseProviderFromArgs = (cliArgs = []) => {
  for (let index = 0; index < cliArgs.length; index += 1) {
    const arg = cliArgs[index];

    if (arg === '--provider' || arg.startsWith('--provider=')) {
      const value = arg === '--provider' ? cliArgs[index + 1] : arg.split('=')[1];
      if (value && typeof value === 'string' && value.trim()) {
        return value.trim().toLowerCase();
      }
    }
  }

  return undefined;
};

const determineClaudeProvider = (cliArgs = [], envFromFile = {}) => {
  const fromArgs = parseProviderFromArgs(cliArgs);
  if (fromArgs) {
    return fromArgs;
  }

  for (const key of CLAUDE_PROVIDER_ENV_KEYS) {
    const value = process.env[key] || envFromFile[key];
    if (typeof value === 'string' && value.trim()) {
      return value.trim().toLowerCase();
    }
  }

  return undefined;
};

const promptForInput = (question) =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    // Timeout after 5 minutes to prevent hanging
    const timeout = setTimeout(() => {
      cleanup();
      reject(new Error('Input prompt timed out after 5 minutes'));
    }, 300000);

    rl.on('error', (error) => {
      clearTimeout(timeout);
      cleanup();
      reject(error);
    });

    rl.question(question, (answer) => {
      clearTimeout(timeout);
      cleanup();
      resolve(answer);
    });
  });

const promptForGlmCredentials = async ({ existingBaseUrl } = {}) => {
  console.log('🔐 GLM provider selected. A Z.AI API token is required.');

  let apiKey;
  while (!apiKey) {
    // eslint-disable-next-line no-await-in-loop
    const input = await promptForInput('Enter your Z.AI GLM API token: ');
    const trimmed = (input || '').trim();
    if (trimmed) {
      apiKey = trimmed;
    } else {
      console.log('⚠️ Token cannot be empty. Please provide a valid value.');
    }
  }

  const baseUrlPrompt = existingBaseUrl
    ? `Enter a custom GLM base URL (leave blank to keep ${existingBaseUrl}): `
    : 'Enter a custom GLM base URL (leave blank for the CLI default): ';
  const baseUrlInput = await promptForInput(baseUrlPrompt);
  const baseUrl = (baseUrlInput || '').trim();

  return { apiKey, baseUrl: baseUrl || undefined };
};

const promptToPersistGlmEnv = async () => {
  if (!isInteractiveTerminal()) {
    return false;
  }

  try {
    const answer = await promptForInput(
      'Would you like to save these GLM credentials to .env for future runs? (y/N): ',
    );
    const normalized = (answer || '').trim().toLowerCase();
    return normalized === 'y' || normalized === 'yes';
  } catch (error) {
    console.warn(
      `⚠️ Skipping persistence prompt due to an input error: ${error.message || error}`,
    );
    return false;
  }
};

const persistEnvValues = (envPath, updates) => {
  const normalizedUpdates = Object.entries(updates).reduce((acc, [key, value]) => {
    if (typeof value === 'string' && value) {
      // Validate no newlines in values
      if (value.includes('\n') || value.includes('\r')) {
        console.warn(`⚠️ Skipping ${key}: value contains newline characters`);
        return acc;
      }
      acc[key] = value;
    }
    return acc;
  }, {});

  const updateKeys = Object.keys(normalizedUpdates);
  if (updateKeys.length === 0) {
    return;
  }

  let lines = [];
  if (fs.existsSync(envPath)) {
    lines = fs.readFileSync(envPath, 'utf8').split(/\r?\n/);
  }

  const seenKeys = new Set();
  const updatedLines = lines.map((line) => {
    const match = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=(.*)$/);
    if (!match) {
      return line;
    }

    const key = match[1];
    if (Object.prototype.hasOwnProperty.call(normalizedUpdates, key)) {
      seenKeys.add(key);
      return `${key}=${normalizedUpdates[key]}`;
    }

    return line;
  });

  for (const key of updateKeys) {
    if (!seenKeys.has(key)) {
      updatedLines.push(`${key}=${normalizedUpdates[key]}`);
    }
  }

  const finalContent = updatedLines.join('\n') + '\n';

  fs.writeFileSync(envPath, finalContent);
  console.log('⚠️  WARNING: Keep this file secure and never commit it to version control.');
};

const ensureClaudeEnvironment = async ({ projectRoot, userArgs = [] }) => {
  const { values: fileEnv, path: envPath } = readProjectEnv(projectRoot);

  const anthropicToken = process.env.ANTHROPIC_AUTH_TOKEN || fileEnv.ANTHROPIC_AUTH_TOKEN;
  if (anthropicToken && !process.env.ANTHROPIC_AUTH_TOKEN) {
    process.env.ANTHROPIC_AUTH_TOKEN = anthropicToken;
  }

  const processApiKey = resolveEnvValue(process.env, GLM_API_KEY_ENV_KEYS);
  const fileApiKey = resolveEnvValue(fileEnv, GLM_API_KEY_ENV_KEYS);
  const processBaseUrl = resolveEnvValue(process.env, GLM_BASE_URL_ENV_KEYS);
  const fileBaseUrl = resolveEnvValue(fileEnv, GLM_BASE_URL_ENV_KEYS);
  const processAuthToken = resolveEnvValue(process.env, GLM_AUTH_TOKEN_ENV_KEYS);
  const fileAuthToken = resolveEnvValue(fileEnv, GLM_AUTH_TOKEN_ENV_KEYS);

  const glmApiKey = processApiKey.value || fileApiKey.value;
  const glmBaseUrl = processBaseUrl.value || fileBaseUrl.value;
  const glmAuthToken = processAuthToken.value || fileAuthToken.value;

  if (!processApiKey.value && fileApiKey.value) {
    setProcessEnvIfMissing(fileApiKey.key, fileApiKey.value);
  }

  if (!processBaseUrl.value && fileBaseUrl.value) {
    setProcessEnvIfMissing(fileBaseUrl.key, fileBaseUrl.value);
  }

  if (!processAuthToken.value && fileAuthToken.value) {
    setProcessEnvIfMissing(fileAuthToken.key, fileAuthToken.value);
  }

  setProcessEnvIfMissing('AGILAI_GLM_API_KEY', glmApiKey);
  setProcessEnvIfMissing('AGILAI_GLM_BASE_URL', glmBaseUrl);
  setProcessEnvIfMissing('AGILAI_GLM_AUTH_TOKEN', glmAuthToken);

  const legacyBmadApiKeyDetected = Boolean(process.env.BMAD_GLM_API_KEY || hasOwn(fileEnv, 'BMAD_GLM_API_KEY'));
  const legacyBmadBaseDetected = Boolean(process.env.BMAD_GLM_BASE_URL || hasOwn(fileEnv, 'BMAD_GLM_BASE_URL'));
  const legacyBmadAuthDetected = Boolean(process.env.BMAD_GLM_AUTH_TOKEN || hasOwn(fileEnv, 'BMAD_GLM_AUTH_TOKEN'));
  const legacyGlmApiKeyDetected = Boolean(process.env.GLM_API_KEY || hasOwn(fileEnv, 'GLM_API_KEY'));
  const legacyGlmBaseDetected = Boolean(process.env.GLM_BASE_URL || hasOwn(fileEnv, 'GLM_BASE_URL'));
  const legacyGlmAuthDetected = Boolean(process.env.GLM_AUTH_TOKEN || hasOwn(fileEnv, 'GLM_AUTH_TOKEN'));
  const legacyZhipuKeyDetected = Boolean(process.env.ZHIPUAI_API_KEY || hasOwn(fileEnv, 'ZHIPUAI_API_KEY'));

  if (legacyGlmApiKeyDetected) {
    setProcessEnvIfMissing('GLM_API_KEY', glmApiKey);
  }

  if (legacyGlmBaseDetected) {
    setProcessEnvIfMissing('GLM_BASE_URL', glmBaseUrl);
  }

  if (legacyGlmAuthDetected) {
    setProcessEnvIfMissing('GLM_AUTH_TOKEN', glmAuthToken);
  }

  if (legacyBmadApiKeyDetected) {
    setProcessEnvIfMissing('BMAD_GLM_API_KEY', glmApiKey);
  }

  if (legacyBmadBaseDetected) {
    setProcessEnvIfMissing('BMAD_GLM_BASE_URL', glmBaseUrl);
  }

  if (legacyBmadAuthDetected) {
    setProcessEnvIfMissing('BMAD_GLM_AUTH_TOKEN', glmAuthToken);
  }

  if (legacyZhipuKeyDetected) {
    setProcessEnvIfMissing('ZHIPUAI_API_KEY', glmApiKey);
  }

  const provider = determineClaudeProvider(userArgs, fileEnv);
  if (provider !== 'glm') {
    return;
  }

  const effectiveBaseUrl = glmBaseUrl;

  if (glmApiKey) {
    return;
  }

  if (!isInteractiveTerminal()) {
    console.error('❌ GLM provider selected but no GLM API key is configured.');
    console.error(
      '   Provide AGILAI_GLM_API_KEY (or legacy GLM_API_KEY / BMAD_GLM_API_KEY) and optional AGILAI_GLM_BASE_URL before running in non-interactive mode.',
    );
    process.exit(1);
  }

  let credentials;
  try {
    credentials = await promptForGlmCredentials({ existingBaseUrl: effectiveBaseUrl });
  } catch (error) {
    console.error('❌ Failed to read GLM credentials:', error.message || error);
    process.exit(1);
  }

  process.env.AGILAI_GLM_API_KEY = credentials.apiKey;
  if (legacyGlmApiKeyDetected && !process.env.GLM_API_KEY) {
    process.env.GLM_API_KEY = credentials.apiKey;
  }
  if (legacyBmadApiKeyDetected && !process.env.BMAD_GLM_API_KEY) {
    process.env.BMAD_GLM_API_KEY = credentials.apiKey;
  }
  if (legacyZhipuKeyDetected && !process.env.ZHIPUAI_API_KEY) {
    process.env.ZHIPUAI_API_KEY = credentials.apiKey;
  }

  if (credentials.baseUrl) {
    process.env.AGILAI_GLM_BASE_URL = credentials.baseUrl;
    if (legacyGlmBaseDetected && !process.env.GLM_BASE_URL) {
      process.env.GLM_BASE_URL = credentials.baseUrl;
    }
    if (legacyBmadBaseDetected && !process.env.BMAD_GLM_BASE_URL) {
      process.env.BMAD_GLM_BASE_URL = credentials.baseUrl;
    }
  } else if (effectiveBaseUrl) {
    setProcessEnvIfMissing('AGILAI_GLM_BASE_URL', effectiveBaseUrl);
    if (legacyGlmBaseDetected) {
      setProcessEnvIfMissing('GLM_BASE_URL', effectiveBaseUrl);
    }
    if (legacyBmadBaseDetected) {
      setProcessEnvIfMissing('BMAD_GLM_BASE_URL', effectiveBaseUrl);
    }
  }

  if (glmAuthToken) {
    setProcessEnvIfMissing('AGILAI_GLM_AUTH_TOKEN', glmAuthToken);
  }

  const shouldPersist = await promptToPersistGlmEnv();
  if (!shouldPersist) {
    console.log('ℹ️ Skipped saving GLM credentials to .env.');
    return;
  }

  const updates = {};
  updates[chooseWriteKey(fileEnv, GLM_API_KEY_ENV_KEYS)] = credentials.apiKey;
  const baseToPersist = credentials.baseUrl || effectiveBaseUrl;
  if (baseToPersist) {
    updates[chooseWriteKey(fileEnv, GLM_BASE_URL_ENV_KEYS)] = baseToPersist;
  }

  try {
    persistEnvValues(envPath, updates);
    const relativeEnvPath = path.relative(process.cwd(), envPath) || '.env';
    console.log(`💾 Saved GLM credentials to ${relativeEnvPath}`);
  } catch (error) {
    console.warn(`⚠️ Unable to persist GLM credentials: ${error.message || error}`);
  }
};

const createDefaultRuntimeOptions = () => ({
  llmProvider: undefined,
  llmModel: undefined,
});

let runtimeOptions = createDefaultRuntimeOptions();

const VALID_LLM_PROVIDERS = new Set(['claude', 'glm', 'openai', 'gpt', 'gemini', 'google']);

const normalizeLlmProvider = (value) => {
  if (!value) {
    return undefined;
  }

  const normalized = value.toLowerCase();

  if (normalized === 'anthropic') {
    return 'claude';
  }

  if (normalized === 'zhipu') {
    return 'glm';
  }

  return normalized;
};

const parseLlmOptionsFromArgs = (currentArgs) => {
  let provider;
  let model;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--glm') {
      provider = 'glm';
      continue;
    }

    if (arg === '--anthropic') {
      provider = 'claude';
      continue;
    }

    if (arg === '--llm-provider') {
      provider = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-provider=')) {
      provider = arg.split('=')[1];
      continue;
    }

    if (arg === '--llm-model') {
      model = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-model=')) {
      model = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  return { provider: normalizeLlmProvider(provider), model, sanitized };
};

const consumeLlmOptionsFromArgs = () => {
  if (!args.length) {
    return;
  }

  const { provider, model, sanitized } = parseLlmOptionsFromArgs(args);
  args.splice(0, args.length, ...sanitized);

  if (provider) {
    if (!VALID_LLM_PROVIDERS.has(provider)) {
      console.error('⚠️ Unsupported LLM provider flag value:', provider);
      console.error('Valid providers:', Array.from(VALID_LLM_PROVIDERS).join(', '));
      process.exit(1);
      return;
    }

    runtimeOptions.llmProvider = provider;
  }

  if (model) {
    runtimeOptions.llmModel = model;
  }
};

const buildSpawnEnv = () => {
  const env = { ...process.env };
  const legacyBmadProviderDetected = typeof process.env.BMAD_ASSISTANT_PROVIDER === 'string';
  const legacyBmadApiKeyDetected = typeof process.env.BMAD_GLM_API_KEY === 'string';
  const legacyBmadBaseDetected = typeof process.env.BMAD_GLM_BASE_URL === 'string';
  const legacyBmadAuthDetected = typeof process.env.BMAD_GLM_AUTH_TOKEN === 'string';
  const legacyGlmApiKeyDetected = typeof process.env.GLM_API_KEY === 'string';
  const legacyGlmBaseDetected = typeof process.env.GLM_BASE_URL === 'string';
  const legacyGlmAuthDetected = typeof process.env.GLM_AUTH_TOKEN === 'string';
  const legacyZhipuKeyDetected = typeof process.env.ZHIPUAI_API_KEY === 'string';

  if (runtimeOptions.llmProvider) {
    env.LLM_PROVIDER = runtimeOptions.llmProvider;
    env.AGILAI_ASSISTANT_PROVIDER = runtimeOptions.llmProvider;
    env.BMAD_ASSISTANT_PROVIDER = runtimeOptions.llmProvider;

    if (runtimeOptions.llmProvider === 'glm') {
      const existingKey =
        env.AGILAI_GLM_API_KEY || env.BMAD_GLM_API_KEY || env.GLM_API_KEY || env.ZHIPUAI_API_KEY;
      const existingBase =
        env.AGILAI_GLM_BASE_URL || env.BMAD_GLM_BASE_URL || env.GLM_BASE_URL;
      const existingAuth =
        env.AGILAI_GLM_AUTH_TOKEN || env.BMAD_GLM_AUTH_TOKEN || env.GLM_AUTH_TOKEN;

      if (existingKey && !env.AGILAI_GLM_API_KEY) {
        env.AGILAI_GLM_API_KEY = existingKey;
      }
      if (existingBase && !env.AGILAI_GLM_BASE_URL) {
        env.AGILAI_GLM_BASE_URL = existingBase;
      }
      if (existingAuth && !env.AGILAI_GLM_AUTH_TOKEN) {
        env.AGILAI_GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyGlmApiKeyDetected && !env.GLM_API_KEY && existingKey) {
        env.GLM_API_KEY = existingKey;
      }
      if (legacyGlmBaseDetected && !env.GLM_BASE_URL && existingBase) {
        env.GLM_BASE_URL = existingBase;
      }
      if (legacyGlmAuthDetected && !env.GLM_AUTH_TOKEN && existingAuth) {
        env.GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyBmadApiKeyDetected && !env.BMAD_GLM_API_KEY && existingKey) {
        env.BMAD_GLM_API_KEY = existingKey;
      }
      if (legacyBmadBaseDetected && !env.BMAD_GLM_BASE_URL && existingBase) {
        env.BMAD_GLM_BASE_URL = existingBase;
      }
      if (legacyBmadAuthDetected && !env.BMAD_GLM_AUTH_TOKEN && existingAuth) {
        env.BMAD_GLM_AUTH_TOKEN = existingAuth;
      }

      // Always set ZHIPUAI_API_KEY for GLM mode if we have a key
      if (existingKey && !env.ZHIPUAI_API_KEY) {
        env.ZHIPUAI_API_KEY = existingKey;
      }
    }
  }

  if (runtimeOptions.llmModel) {
    env.LLM_MODEL = runtimeOptions.llmModel;
  }

  return env;
};

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;
const loadCompanionIntegrationConfig = () => {
  const configPath = path.join(
    __dirname,
    '..',
    'packages',
    'meta-agents',
    'config',
    'compounding-engineering.json',
  );

  try {
    const raw = fs.readFileSync(configPath, 'utf8');
    return { path: configPath, config: JSON.parse(raw) };
  } catch (error) {
    return {
      path: configPath,
      config: undefined,
      error,
    };
  }
};

const resolveCompanionRepoPath = (config) => {
  const overrideRoot = process.env.COMPOUNDING_ENGINEERING_ROOT;
  if (overrideRoot && typeof overrideRoot === 'string' && overrideRoot.trim()) {
    const resolved = path.resolve(overrideRoot);
    return resolved;
  }

  if (!config || typeof config.repositoryPath !== 'string') {
    return undefined;
  }

  const repositoryPath = config.repositoryPath;
  const resolved = path.isAbsolute(repositoryPath)
    ? repositoryPath
    : path.join(__dirname, '..', repositoryPath);

  return resolved;
};

const printHelp = () => {
  console.log(`
AiDesigner - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx aidesigner@latest <command> [options]

Options:
  --assistant=<assistant>    Launch specified CLI front-end (claude, codex, opencode)
  --llm-provider=<provider>  Override orchestrator LLM (claude, glm, openai, gemini)
  --llm-model=<model>        Force a specific model id for the orchestrator
  --glm                      Shortcut for --llm-provider=glm (uses ZHIPUAI_API_KEY)
  --anthropic                Shortcut for --llm-provider=claude

Commands:

  start                🚀 ONE-COMMAND SETUP: init + install + prompt for assistant choice
  init                 Initialize AiDesigner in current project
  chat                 Start conversational interface with Claude CLI (Anthropic/GLM)
  codex                Start conversational interface with Codex CLI
  opencode             Start conversational interface with OpenCode CLI

  workflow start <id>  Run meta-agent workflow (genesis | librarian | refactor)

  install              Install AiDesigner globally
  companion-sync       Validate the built-in compounding-engineering planner assets
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  review              Display Drawbridge review queue summary
  help                 Show this help message

Examples:

  npx aidesigner@latest start      # 🚀 Do everything in one command!

  # Claude CLI (supports: anthropic, glm)
  npx aidesigner@latest start --assistant=claude --provider=glm
                                      # Launch Claude CLI with GLM API
  npx aidesigner@latest start --assistant=claude-glm
                                      # Combined flag also supported

  # Codex CLI (supports: openai only)
  npx aidesigner@latest start --assistant=codex --provider=openai
                                      # Launch Codex CLI with OpenAI/GPT

  # OpenCode CLI (supports: anthropic, glm, openai, gemini)
  npx aidesigner@latest start --assistant=opencode --provider=glm
                                      # Launch OpenCode with GLM API

  npx aidesigner@latest start --glm
                                      # Use GLM with AGILAI_GLM_API_KEY (preferred)
  npx aidesigner@latest init       # Setup in current project
  npm run codex                        # Start conversation (after install)


Flags:
  Use --assistant and optionally --provider to skip prompts. Combine values like
  --assistant=claude-glm when preferred.


💡 Tip: Always use @latest to get the newest version:
   npx aidesigner@latest start

Environment:
  Set AGILAI_GLM_API_KEY (preferred) or legacy GLM_API_KEY/ZHIPUAI_API_KEY and optionally LLM_MODEL when using --glm.
  Use --anthropic or LLM_PROVIDER=claude to switch back to Anthropic defaults.

For more information: https://github.com/bacoco/AiDesigner
`);
};

const ASSISTANT_CHOICES = [
  {
    id: 'claude',
    providers: ['anthropic', 'glm'], // Claude CLI only supports Anthropic and GLM APIs
  },
  {
    id: 'codex',
    providers: ['openai'], // Codex CLI only supports OpenAI/GPT models
  },
  {
    id: 'opencode',
    providers: ['anthropic', 'glm', 'openai', 'gemini'], // OpenCode supports all providers
  },
];

const findAssistantChoice = (id) =>
  ASSISTANT_CHOICES.find((choice) => choice.id === id);

const listAssistantIds = () => ASSISTANT_CHOICES.map(({ id }) => id);

const splitAssistantAndProvider = (value) => {
  if (!value) {
    return { assistant: undefined, provider: undefined };
  }

  const normalized = value.toLowerCase();
  const [assistantPart, ...providerParts] = normalized.split('-');
  const provider = providerParts.length > 0 ? providerParts.join('-') : undefined;

  return {
    assistant: assistantPart,
    provider,
  };
};

const OPTIONAL_MCP_SERVERS = [
  {
    id: 'github',
    label: 'GitHub repository operations',
    description: 'Git operations and GitHub API via MCP.',
    recommended: true,
    envPrompts: [
      {
        key: 'GITHUB_PERSONAL_ACCESS_TOKEN',
        prompt: 'Enter your GitHub Personal Access Token (or leave blank to skip)',
      },
    ],
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-github'],
      disabled: false,
    },
  },
  {
    id: 'chrome-devtools',
    label: 'Chrome DevTools bridge',
    description: 'Inspect and control active Chrome tabs via the DevTools protocol. Requires Chrome.',
    recommended: false,
    config: {
      command: 'npx',
      args: ['-y', 'chrome-devtools-mcp', '--headless'],
      disabled: false,
    },
  },
  {
    id: 'shadcn-ui',
    label: 'shadcn/ui component generator',
    description: 'Generate UI components from the shadcn library.',
    recommended: false,
    config: {
      command: 'npx',
      args: ['-y', '@jpisnice/shadcn-ui-mcp-server'],
      disabled: false,
    },
  },
  {
    id: 'tweakcn',
    label: 'TweakCN theme assistant',
    description: 'Sync Tailwind tokens and themes between TweakCN and AiDesigner workflows.',
    recommended: false,
    envPrompts: [
      {
        key: 'TWEAKCN_THEME_PREVIEW_URL',
        prompt: 'Enter your TweakCN theme preview URL (optional, press Enter to skip)',
      },
      {
        key: 'TWEAKCN_API_TOKEN',
        prompt: 'Enter your TweakCN API token (optional, press Enter to skip)',
      },
    ],
    config: {
      command: 'npx',
      args: ['-y', 'tweakcn-mcp-server'],
      disabled: false,
    },
  },
];

const formatAssistantName = (value) =>
  value.charAt(0).toUpperCase() + value.slice(1);

const parseAssistantFromArgs = (currentArgs) => {
  let assistant;
  let provider;
  let providerExplicit = false;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--assistant') {
      assistant = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--assistant=')) {
      assistant = arg.split('=')[1];
      continue;
    }

    if (arg === '--provider') {
      provider = currentArgs[index + 1];
      index += 1;
      providerExplicit = true;
      continue;
    }

    if (arg.startsWith('--provider=')) {
      provider = arg.split('=')[1];
      providerExplicit = true;
      continue;
    }

    sanitized.push(arg);
  }

  if (assistant) {
    const { assistant: parsedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistant);
    assistant = parsedAssistant;
    if (!provider && combinedProvider) {
      provider = combinedProvider;
      providerExplicit = true;
    }
  }

  return {
    assistant: assistant ? assistant.toLowerCase() : undefined,
    provider: provider ? provider.toLowerCase() : undefined,
    providerExplicit,
    sanitized,
  };
};

/**
 * Provider label and description mappings for interactive selection
 */
const PROVIDER_LABELS = {
  anthropic: 'Anthropic',
  glm: 'GLM',
  openai: 'OpenAI',
  gemini: 'Gemini'
};

const PROVIDER_DESCRIPTIONS = {
  anthropic: 'Advanced reasoning and coding',
  glm: 'Chinese language excellence',
  openai: 'General purpose AI',
  gemini: 'Multimodal capabilities'
};

const promptForAssistant = async () => {
  if (!isInteractiveTerminal()) {
    console.error('⚠️ Interactive mode requires a TTY terminal');
    return undefined;
  }

  try {
    // Build all valid CLI-provider combinations
    const choices = [];
    for (const choice of ASSISTANT_CHOICES) {
      for (const provider of choice.providers) {
        const cliName = formatAssistantName(choice.id) + ' CLI';
        const providerLabel = PROVIDER_LABELS[provider];
        const description = PROVIDER_DESCRIPTIONS[provider];

        choices.push({
          name: `${cliName} → ${providerLabel} - ${description}`,
          value: { assistant: choice.id, provider },
          short: `${cliName} → ${providerLabel}`
        });
      }
    }

    const { selection } = await inquirer.prompt([{
      type: 'list',
      name: 'selection',
      message: 'Select CLI and provider:',
      choices,
      default: { assistant: 'claude', provider: 'anthropic' }
    }]);

    return {
      assistant: selection.assistant,
      provider: selection.provider,
      providerExplicit: true
    };
  } catch (error) {
    console.warn('⚠️ Selection cancelled or failed:', error.message || error);
    return undefined;
  }
};

const determineAssistant = async (input = {}) => {
  if (typeof input === 'string' || input === undefined) {
    return determineAssistant({ assistant: input });
  }

  const { assistant: assistantFlag, provider: providerFlag, providerExplicit: providerExplicitFromInput } = input;
  if (assistantFlag) {
    const { assistant: normalizedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistantFlag);
    let provider = providerFlag || combinedProvider;
    let providerExplicit =
      Boolean(providerFlag) || (combinedProvider ? providerExplicitFromInput !== false : false);
    const choice = findAssistantChoice(normalizedAssistant);

    if (!choice) {
      console.error('⚠️ Unsupported assistant flag value:', assistantFlag);
      console.error('Valid options:', listAssistantIds().join(', '));
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (provider && !choice.providers.includes(provider)) {
      console.error(
        `⚠️ Unsupported provider "${provider}" for ${normalizedAssistant} CLI.`,
      );
      console.error(
        `   Supported providers for ${normalizedAssistant}: ${choice.providers.join(', ')}`,
      );
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (!provider) {
      [provider] = choice.providers;
      providerExplicit = false;
    }

    return { assistant: choice.id, provider, providerExplicit };
  }

  if (!process.stdout.isTTY) {
    console.error(
      '⚠️ Non-interactive mode requires --assistant flag. Use: --assistant=claude, --assistant=claude-glm, or combine with --provider.',
    );
    process.exit(1);
    return; // For testing when exit is mocked
  }

  return promptForAssistant();
};

/**
 * Prompts user to select MCP servers using interactive checkbox
 * @returns {Promise<string[]>} Array of selected server IDs
 */
const promptForMcpServers = async () => {
  if (!isInteractiveTerminal()) {
    return [];
  }

  try {
    const choices = OPTIONAL_MCP_SERVERS.map(server => ({
      name: `${server.label} — ${server.description}`,
      value: server.id,
      short: server.label,
      checked: server.recommended || false
    }));

    const { servers } = await inquirer.prompt([{
      type: 'checkbox',
      name: 'servers',
      message: 'Select MCP servers to enable (Space to toggle, Enter to confirm):',
      choices,
      pageSize: 10
    }]);

    return servers;
  } catch (error) {
    console.warn('⚠️ MCP server selection cancelled or failed:', error.message || error);
    return [];
  }
};

// Task status constants
const TASK_STATUS = {
  PENDING: 'pending',
  RESOLVED: 'resolved',
  DONE: 'done',
  CLOSED: 'closed',
  COMPLETE: 'complete',
  COMPLETED: 'completed',
  APPROVED: 'approved',
};

const RESOLVED_STATUSES = new Set([
  TASK_STATUS.RESOLVED,
  TASK_STATUS.DONE,
  TASK_STATUS.CLOSED,
  TASK_STATUS.COMPLETE,
  TASK_STATUS.COMPLETED,
  TASK_STATUS.APPROVED,
]);

// Severity levels for sorting
const SEVERITY_ORDER = ['critical', 'high', 'medium', 'low'];

const formatDateTime = (value) => {
  if (!value) {
    return 'unknown';
  }

  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return `${date.toISOString().replace('T', ' ').replace('Z', ' UTC')}`;
};

const groupReviewQueueByPack = (queue) => {
  const grouped = new Map();

  for (const item of queue) {
    const key = item.packId || item.ingestionId || 'untracked-pack';
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(item);
  }

  return grouped;
};

const printDrawbridgeReviewQueue = (queue, { includeResolved = false } = {}) => {
  console.log('📝 Drawbridge Review Queue');
  console.log(`   Items pending: ${queue.length}`);
  console.log(`   Resolved included: ${includeResolved ? 'yes' : 'no'}`);
  console.log('');

  const grouped = groupReviewQueueByPack(queue);

  for (const [packId, items] of grouped.entries()) {
    const sorted = items.slice().sort((a, b) => {
      const aSeverity = SEVERITY_ORDER.indexOf((a.severity || '').toLowerCase());
      const bSeverity = SEVERITY_ORDER.indexOf((b.severity || '').toLowerCase());

      if (aSeverity !== bSeverity) {
        return (aSeverity === -1 ? SEVERITY_ORDER.length : aSeverity) - (bSeverity === -1 ? SEVERITY_ORDER.length : bSeverity);
      }

      // Fix sorting inconsistency: sort by newest first (descending) to match main queue
      if (a.ingestedAt && b.ingestedAt && a.ingestedAt !== b.ingestedAt) {
        return new Date(b.ingestedAt).getTime() - new Date(a.ingestedAt).getTime();
      }

      return (a.id || '').localeCompare(b.id || '');
    });

    const modeLabel = items[0]?.mode || 'n/a';
    const ingested = formatDateTime(items[0]?.ingestedAt);
    console.log(`Pack: ${packId} (mode: ${modeLabel}, ingested ${ingested})`);
    for (const task of sorted) {
      const selectors = task.selectors && task.selectors.length > 0 ? task.selectors.join(', ') : 'no selector';
      const status = task.status || 'pending';
      const severity = task.severity || 'unspecified';
      console.log(`  • ${task.id || 'item'} — ${task.summary}`);
      console.log(`      lane: ${task.lane || 'n/a'} | status: ${status} | severity: ${severity}`);
      console.log(`      selectors: ${selectors}`);
      if (task.screenshot) {
        console.log(`      screenshot: ${task.screenshot}`);
      }
    }
    console.log('');
  }
};

// Command handlers
const commands = {
  start: async () => {
    console.log('🚀 Starting AiDesigner setup...\n');

    consumeLlmOptionsFromArgs();

    // Determine assistant preference before installation begins
    const {
      assistant: assistantFlag,
      provider: providerFlag,
      providerExplicit,
      sanitized,
    } = parseAssistantFromArgs(args);
    args.splice(0, args.length, ...sanitized);
    const selection = await determineAssistant({
      assistant: assistantFlag,
      provider: providerFlag,
      providerExplicit,
    });

    // If selection is undefined, exit was called (possibly mocked in tests)
    if (!selection) {
      return;
    }

      const {
        assistant,
        provider,
        providerExplicit: providerWasExplicit,
      } = selection;
      const choice = findAssistantChoice(assistant);
      let resolvedProvider = provider;

    // Override provider to GLM when --glm flag is used, the assistant supports GLM,
    // and the user didn't explicitly select a different provider via --provider flag
    if (
      runtimeOptions.llmProvider === 'glm' &&
      choice?.providers.includes('glm') &&
      resolvedProvider !== 'glm' &&
        !providerWasExplicit
      ) {
        resolvedProvider = 'glm';
      }

    process.env.AGILAI_ASSISTANT_PROVIDER = resolvedProvider;
    if (process.env.BMAD_ASSISTANT_PROVIDER) {
      process.env.BMAD_ASSISTANT_PROVIDER = resolvedProvider;
    }

    if (process.stdout.isTTY) {
      console.log(
        '💡 We can optionally enable additional MCP servers (chrome-devtools, shadcn, tweakcn) during setup.',
      );
    }

    // Run init
    await commands.init();

    // Run npm install
    console.log('\n📦 Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    const assistantName = formatAssistantName(assistant);
    const providerLabel = resolvedProvider ? ` (${resolvedProvider})` : '';
    console.log(
      `\n🎯 Starting AiDesigner Orchestrator with ${assistantName}${providerLabel}...\n`,
    );

    if (assistant === 'claude') {
      await commands.chat();
      return;
    }

    if (assistant === 'opencode') {
      // Ensure GLM credentials are configured if using GLM provider
      if (resolvedProvider === 'glm') {
        await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });
      }
      await commands.opencode();
      return;
    }

    await commands.codex();
  },

  init: async () => {
    console.log('🚀 Initializing AiDesigner...\n');

    let projectName;
    let projectRoot;

    // Interactive project name prompt
    if (isInteractiveTerminal()) {
      const { name } = await inquirer.prompt([{
        type: 'input',
        name: 'name',
        message: '📁 What is your project name?',
        default: 'my-project',
        validate: (input) => {
          if (!input || input.trim() === '') {
            return 'Project name cannot be empty';
          }
          if (!/^[a-zA-Z0-9-_]+$/.test(input)) {
            return 'Project name can only contain letters, numbers, hyphens, and underscores';
          }
          return true;
        }
      }]);

      projectName = name;
      projectRoot = path.join(process.cwd(), projectName);
    } else {
      // Non-interactive: use current directory name
      projectName = path.basename(process.cwd());
      projectRoot = process.cwd();
    }

    console.log(`\n🎯 Initializing project: ${projectName}\n`);

    // Create and enter project directory (interactive mode only)
    if (isInteractiveTerminal() && projectRoot !== process.cwd()) {
      if (fs.existsSync(projectRoot)) {
        const { overwrite } = await inquirer.prompt([{
          type: 'confirm',
          name: 'overwrite',
          message: `Directory "${projectName}" already exists. Initialize AiDesigner here?`,
          default: true
        }]);

        if (!overwrite) {
          console.log('❌ Initialization cancelled');
          return;
        }
      } else {
        fs.mkdirSync(projectRoot, { recursive: true });
        console.log(`✅ Created project directory: ${projectName}`);
      }

      process.chdir(projectRoot);
      console.log(`📂 Working in: ${projectRoot}\n`);
    } else {
      projectRoot = process.cwd();
    }

    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('📦 Creating package.json...');
      const defaultPackage = {
        name: projectName,
        version: '1.0.0',
        description: 'Project powered by AiDesigner',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('✅ Created package.json');
    }

    // Create .aidesigner directory
    const aidesignerDir = path.join(projectRoot, '.aidesigner');
    if (!fs.existsSync(aidesignerDir)) {
      fs.mkdirSync(aidesignerDir, { recursive: true });
      console.log('✅ Created .aidesigner directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('✅ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    // Use .mcp.json in project root for better Claude CLI compatibility
    const mcpConfigDest = path.join(projectRoot, '.mcp.json');
    let mcpConfig = { mcpServers: {} };
    let hadExistingMcpConfig = false;
    if (fs.existsSync(mcpConfigDest)) {
      try {
        const parsed = JSON.parse(fs.readFileSync(mcpConfigDest, 'utf8'));
        if (parsed && typeof parsed === 'object' && parsed.mcpServers) {
          // Preserve all top-level keys (logging, environment, etc.), not just mcpServers
          mcpConfig = { ...parsed };
          mcpConfig.mcpServers = { ...parsed.mcpServers };
          hadExistingMcpConfig = true;
        }
      } catch (error) {
        console.warn('⚠️ Failed to parse existing MCP configuration. Rebuilding from defaults.');
      }
    }

    const orchestratorKey = 'aidesigner';
    const legacyOrchestratorKey = 'aidesigner-invisible-orchestrator';
    const orchestratorArgs = ['node_modules/aidesigner/dist/mcp/mcp/server.js'];
    const legacyOrchestratorArgs = new Set([
      'dist/mcp/mcp/server.js',
      './node_modules/aidesigner/dist/mcp/mcp/server.js',
      "require('aidesigner/dist/mcp/mcp/server.js')",
      "require('aidesigner/.dev/dist/mcp/mcp/server.js')",
      './node_modules/aidesigner/dist/mcp/mcp/server.js',
      "require('aidesigner/dist/mcp/mcp/server.js')",
      "require('aidesigner/.dev/dist/mcp/mcp/server.js')",
    ]);
    const orchestratorConfig = {
      command: 'node',
      args: ['node_modules/aidesigner/dist/mcp/mcp/server.js'],
      disabled: false,
    };

    // Remove legacy key if present, preserving any custom configuration
    if (mcpConfig.mcpServers[legacyOrchestratorKey]) {
      const legacyConfig = mcpConfig.mcpServers[legacyOrchestratorKey];

      // Check if the new key already exists
      if (!mcpConfig.mcpServers[orchestratorKey]) {
        // Preserve custom configuration from legacy key if it differs from defaults
        const hasCustomConfig =
          legacyConfig.disabled === true ||
          legacyConfig.env !== undefined ||
          (Array.isArray(legacyConfig.args) && !legacyOrchestratorArgs.has(legacyConfig.args[0]));

        if (hasCustomConfig) {
          // Preserve custom settings but update the args to new path
          mcpConfig.mcpServers[orchestratorKey] = {
            ...legacyConfig,
            args: orchestratorArgs
          };
          console.log('🗑️ Removed legacy orchestrator entry and preserved custom configuration');
        } else {
          // Use default config
          mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
          console.log('🗑️ Removed legacy orchestrator entry');
        }
      } else {
        // New key already exists, just remove legacy
        console.log('🗑️ Removed legacy orchestrator entry (new entry already exists)');
      }

      delete mcpConfig.mcpServers[legacyOrchestratorKey];
    }

    if (!mcpConfig.mcpServers[orchestratorKey]) {
      mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
      console.log('✅ Added AiDesigner orchestrator MCP server');
    } else if (!mcpConfig.mcpServers[legacyOrchestratorKey]) {
      // Ensure orchestrator is enabled during re-init (user may have disabled it)
      const existing = mcpConfig.mcpServers[orchestratorKey];
      existing.disabled = false;
      existing.command = 'node';

      // Check if we need to update args to new format
      const isLegacyPath =
        !Array.isArray(existing.args) ||
        existing.args.length === 0 ||
        (existing.args.length === 1 && legacyOrchestratorArgs.has(existing.args[0])) ||
        (existing.args.length === 2 && existing.args[0] === '-e');

      const needsUpdate = isLegacyPath || (existing.args.length === 1 && existing.args[0] !== orchestratorArgs[0]);

      if (needsUpdate) {
        existing.args = [...orchestratorArgs];
        console.log('✅ Updated AiDesigner MCP server to latest path');
      }
    }

    const promptYesNo = async (question) => {
      if (!process.stdout.isTTY) {
        return false;
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question} (y/N): `, (answer) => {
          cleanup();
          const normalized = (answer || '').trim().toLowerCase();
          resolve(normalized === 'y' || normalized === 'yes');
        });
      });
    };

    const promptInput = async (question) => {
      if (!process.stdout.isTTY) {
        return '';
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question}: `, (answer) => {
          cleanup();
          resolve((answer || '').trim());
        });
      });
    };

    const optionalServerPromptsNeeded = OPTIONAL_MCP_SERVERS.filter(
      ({ id }) => !mcpConfig.mcpServers[id],
    );

    let selectedServerIds = [];

    if (optionalServerPromptsNeeded.length > 0) {
      if (process.stdout.isTTY) {
        // Use interactive multi-select
        console.log('\n📦 Configure MCP servers for your project:\n');
        selectedServerIds = await promptForMcpServers();

        if (selectedServerIds.length === 0) {
          console.log('⏭️ No MCP servers selected - you can add them later via .mcp.json');
        }
      } else {
        console.log(
          'ℹ️ Optional MCP servers detected, but prompts are skipped in non-interactive mode.',
        );
      }
    }

    // Configure selected servers
    for (const serverId of selectedServerIds) {
      const optional = OPTIONAL_MCP_SERVERS.find(s => s.id === serverId);
      if (!optional || mcpConfig.mcpServers[optional.id]) {
        continue;
      }

      const serverConfig = {
        ...optional.config,
        ...(optional.config.env ? { env: { ...optional.config.env } } : {}),
      };

      const envPrompts = Array.isArray(optional.envPrompts)
        ? optional.envPrompts.filter(definition => definition && definition.key && definition.prompt)
        : [];

      if (envPrompts.length > 0) {
        const envAssignments = { ...(serverConfig.env || {}) };

        for (const definition of envPrompts) {
          const { key, prompt: envPrompt, required = false } = definition;

          try {
            const existingValue = envAssignments[key] || process.env[key];
            if (existingValue && typeof existingValue === 'string' && existingValue.trim()) {
              envAssignments[key] = existingValue.trim();
              console.log(`ℹ️  Using ${key} from existing environment`);
              continue;
            }

            const envValue = await promptInput(envPrompt);
            if (envValue) {
              envAssignments[key] = envValue;
              console.log(`✅ Added ${key} to ${optional.label} configuration`);
            } else if (required) {
              console.warn(`⚠️ ${key} is required for ${optional.label}. Add it to .mcp.json when available.`);
            } else {
              console.log(`ℹ️ Skipped ${key} - you can add it manually to .mcp.json later`);
            }
          } catch (error) {
            console.warn(`⚠️ Failed to prompt for ${key}: ${error.message || error}`);
          }
        }

        if (Object.keys(envAssignments).length > 0) {
          serverConfig.env = envAssignments;
        } else {
          delete serverConfig.env;
        }
      }

      mcpConfig.mcpServers[optional.id] = serverConfig;
      console.log(`✅ Added MCP server: ${optional.label}`);
    }

    fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2) + '\n');
    console.log(
      hadExistingMcpConfig
        ? '✅ Updated MCP configuration with selected servers'
        : '✅ Created MCP configuration',
    );

    // Create BMAD-compliant directory structure
    const directories = [
      'docs',              // Root for all documentation
      'docs/prd',          // Sharded PRD (created by PO)
      'docs/architecture', // Sharded architecture (created by PO)
      'docs/stories',      // User stories (created by SM)
      'docs/qa',           // QA assessments and gates
      'docs/qa/assessments',
      'docs/qa/gates',
    ];

    for (const dir of directories) {
      const dirPath = path.join(projectRoot, dir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }
    }

    console.log('✅ Created BMAD directory structure');
    console.log('   📁 docs/               (agent-generated documents)');
    console.log('   📁 docs/prd/           (sharded PRD epics)');
    console.log('   📁 docs/architecture/  (sharded architecture)');
    console.log('   📁 docs/stories/       (user stories)');
    console.log('   📁 docs/qa/            (QA assessments & gates)');

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      aidesigner: 'aidesigner start',
      codex: 'aidesigner codex',
      'aidesigner:codex': 'aidesigner codex',
      'aidesigner:claude': 'aidesigner chat',
      'aidesigner:opencode': 'aidesigner opencode',
      'aidesigner:build': 'aidesigner build',
    };

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added npm scripts to package.json');
    }

    const desiredDependencyVersion = `^${currentVersion}`;
    const existingDependencyVersion =
      packageJson.dependencies && packageJson.dependencies.aidesigner;
    const needsDependencyUpdate = existingDependencyVersion !== desiredDependencyVersion;

    if (needsDependencyUpdate) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies.aidesigner = desiredDependencyVersion;
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log(`✅ Ensured aidesigner@${desiredDependencyVersion} is listed in dependencies`);
    }

    // Only create components.json if shadcn MCP server is enabled
    const shadcnEnabled = mcpConfig.mcpServers['shadcn-ui'] && !mcpConfig.mcpServers['shadcn-ui'].disabled;
    if (shadcnEnabled) {
      const componentsPath = path.join(projectRoot, 'components.json');

      // Auto-detect project configuration for smart defaults
      const detectProjectConfig = () => {
        const config = {
          cssPath: 'app/globals.css',
          tailwindConfig: 'tailwind.config.ts',
          useTsx: true,
          useRsc: true,
        };

        // Detect CSS location (common Next.js paths)
        const cssCandidates = [
          'app/globals.css',
          'src/app/globals.css',
          'styles/globals.css',
          'src/styles/globals.css',
        ];
        for (const candidate of cssCandidates) {
          if (fs.existsSync(path.join(projectRoot, candidate))) {
            config.cssPath = candidate;
            break;
          }
        }

        // Detect Tailwind config variant (.ts vs .js)
        if (fs.existsSync(path.join(projectRoot, 'tailwind.config.js'))) {
          config.tailwindConfig = 'tailwind.config.js';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.cjs'))) {
          config.tailwindConfig = 'tailwind.config.cjs';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.mjs'))) {
          config.tailwindConfig = 'tailwind.config.mjs';
        }
        // Default to .ts if nothing found (assume TypeScript project)

        // Detect TypeScript usage
        const hasTsConfig = fs.existsSync(path.join(projectRoot, 'tsconfig.json'));
        const hasTypeScriptDep = fs.existsSync(packagePath) &&
          (() => {
            try {
              const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
              return (pkg.dependencies && pkg.dependencies.typescript) ||
                     (pkg.devDependencies && pkg.devDependencies.typescript);
            } catch {
              return false;
            }
          })();
        config.useTsx = hasTsConfig || hasTypeScriptDep;

        // Detect Next.js App Router vs Pages Router for RSC
        const hasAppDir = fs.existsSync(path.join(projectRoot, 'app')) ||
                         fs.existsSync(path.join(projectRoot, 'src/app'));
        const hasPagesDir = fs.existsSync(path.join(projectRoot, 'pages')) ||
                           fs.existsSync(path.join(projectRoot, 'src/pages'));
        config.useRsc = hasAppDir || !hasPagesDir; // Default to RSC unless Pages Router is clearly used

        return config;
      };

      // Validate shadcn prerequisites
      const validateShadcnPrerequisites = () => {
        const warnings = [];

        try {
          const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
          const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };

          // Check for Next.js (shadcn primarily targets Next.js)
          if (!allDeps.next && !allDeps.react) {
            warnings.push('Neither Next.js nor React detected. shadcn components require React.');
          }

          // Check for Tailwind CSS
          if (!allDeps.tailwindcss) {
            warnings.push('Tailwind CSS not detected. shadcn components require Tailwind CSS.');
          }
        } catch {
          // If we can't read package.json, skip validation (it was just created)
        }

        return warnings;
      };

      const detectedConfig = detectProjectConfig();
      const validationWarnings = validateShadcnPrerequisites();

      // Show validation warnings if any
      if (validationWarnings.length > 0) {
        console.warn('\n⚠️ shadcn prerequisites check:');
        for (const warning of validationWarnings) {
          console.warn(`   • ${warning}`);
        }
        console.warn('   You may need to install these dependencies for shadcn to work properly.\n');
      }

      const shadcnConfig = {
        $schema: 'https://ui.shadcn.com/schema.json',
        style: 'new-york',
        rsc: detectedConfig.useRsc,
        tsx: detectedConfig.useTsx,
        tailwind: {
          config: detectedConfig.tailwindConfig,
          css: detectedConfig.cssPath,
          baseColor: 'zinc',
          cssVariables: true,
        },
        aliases: {
          components: '@/components',
          utils: '@/lib/utils',
        },
        registries: {
          '@originui': 'https://originui.com/r/components.json',
          '@aceternity': 'https://aceternity.com/r/components.json',
          '@magicui': 'https://magicui.design/r/components.json',
        },
      };

      if (!fs.existsSync(componentsPath)) {
        fs.writeFileSync(componentsPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
        console.log('✅ Created shadcn components.json (New York preset)');
        if (detectedConfig.cssPath !== 'app/globals.css' ||
            detectedConfig.tailwindConfig !== 'tailwind.config.ts') {
          console.log(`   📍 Detected paths: ${detectedConfig.cssPath}, ${detectedConfig.tailwindConfig}`);
        }
      } else {
        console.warn('⚠️ components.json already exists. Leaving the current shadcn configuration untouched.');
      }
    } else {
      console.log('ℹ️ Skipped shadcn components.json creation (shadcn MCP server disabled).');
    }

    // Create README.md with BMAD workflow guidance
    const readmePath = path.join(projectRoot, 'README.md');
    const readmeContent = `# ${projectName}

Welcome to your AiDesigner project! This project follows the **BMAD-METHOD™** (Breakthrough Method of Agile AI-driven Development) - a universal AI agent framework that orchestrates specialized AI agents through structured workflows.

## 🚀 Quick Start

### 1. Install Dependencies
\`\`\`bash
npm install
\`\`\`

### 2. Start Development
\`\`\`bash
# Launch Codex CLI for interactive development
npm run aidesigner:codex

# Or use Claude chat
npm run aidesigner:claude
\`\`\`

## 📁 Project Structure

\`\`\`
${projectName}/
├── docs/                    # Generated documentation
│   ├── prd/                # Product requirements (sharded by PO agent)
│   ├── architecture/       # System architecture (sharded by PO agent)
│   ├── stories/            # User stories (created by SM agent)
│   └── qa/                 # QA assessments and gates
│       ├── assessments/
│       └── gates/
├── .aidesigner/                # AiDesigner metadata
└── .mcp.json               # MCP server configuration
\`\`\`

## 🎯 BMAD Workflow

The BMAD methodology follows a structured three-phase workflow:

### Phase 1: Planning (Web UI Recommended)
Use BMAD agents in web-based AI platforms (Gemini, ChatGPT) for comprehensive planning:

1. **Analyst Agent** → Creates project brief and market research
2. **PM Agent** → Generates \`docs/prd.md\` (Product Requirements Document)
3. **Architect Agent** → Creates \`docs/architecture.md\` (System Architecture)
4. **UX Expert Agent** (optional) → Frontend specifications
5. **PO Agent** → Validates and "shards" documents into subdirectories

### Phase 2: Transition to IDE
Copy generated documents to your project:
- \`docs/prd.md\` → sharded into \`docs/prd/epic-*.md\`
- \`docs/architecture.md\` → sharded into \`docs/architecture/\`

### Phase 3: Development (IDE)
Use agents in your IDE (VS Code, Cursor, Claude Code) for implementation:

1. **Scrum Master (SM)** → Creates detailed stories in \`docs/stories/\`
2. **Dev Agent** → Implements features following architecture
3. **QA Agent** → Reviews and validates code quality
4. **Repeat** until epic is complete

## 🤖 Available Agents

BMAD provides specialized agents for different tasks:

- **Analyst**: Market research, requirements gathering, brainstorming
- **PM (Product Manager)**: PRD generation, epic/story breakdown
- **Architect**: Technical architecture, design decisions
- **UX Expert**: Frontend specs, UI/UX design
- **PO (Product Owner)**: Validation, document sharding, alignment
- **SM (Scrum Master)**: Story creation, sprint planning
- **Dev**: Code implementation, feature development
- **QA**: Code review, testing, quality gates

## 📝 How Documents Are Generated

**Important**: You don't manually fill out templates! BMAD agents generate all documentation using:

- **YAML Templates** (in \`aidesigner-core/templates/\`): Define document structure
- **Agent Intelligence**: Agents use these templates to create tailored docs
- **MCP Tools**: Model Context Protocol enables agents to create/modify files

### Example Agent Commands

\`\`\`bash
# In IDE with AiDesigner agent active:
"Use PM agent to create a PRD for user authentication feature"
"Use Architect agent to design the database schema"
"Use SM agent to create stories for Epic 1"
\`\`\`

## 🛠️ Available Commands

\`\`\`bash
# Core Commands
npm run aidesigner          # Start AiDesigner orchestrator
npm run codex           # Launch Codex CLI
npm run aidesigner:codex    # Same as above
npm run aidesigner:claude   # Launch Claude chat
npm run aidesigner:opencode # Open code interface
npm run aidesigner:build    # Build AiDesigner bundles

# Build & Development
npm run build           # Build all agents and bundles
npm run build:agents    # Build agent bundles only
npm run build:mcp       # Build MCP server

# Quality
npm run lint            # Run linter
npm run format          # Format code
npm run test            # Run tests
\`\`\`

## 🔧 Configuration

### MCP Server Configuration
Your MCP servers are configured in \`.mcp.json\`. To modify:
\`\`\`bash
npx aidesigner init  # Re-run to update MCP configuration
\`\`\`

### LLM Provider Configuration
Set your preferred LLM provider via environment variables:
\`\`\`bash
# Claude (Anthropic)
export ANTHROPIC_API_KEY="your-key"

# GLM (ZhipuAI)
export GLM_API_KEY="your-key"
export GLM_BASE_URL="https://open.bigmodel.cn/api/paas/v4"

# OpenAI
export OPENAI_API_KEY="your-key"

# Gemini
export GEMINI_API_KEY="your-key"
\`\`\`

## 📚 Documentation & Resources

- **BMAD Methodology**: [Core Architecture](https://github.com/bacoco/aidesigner)
- **User Guide**: Complete workflow walkthrough
- **Expansion Packs**: Domain-specific extensions (game dev, creative writing, etc.)
- **Community**: [Discord](https://discord.gg/aidesigner) for support and discussions

## 🎓 Learning Path

### New to BMAD?
1. Read the [BMAD User Guide](https://github.com/bacoco/aidesigner/blob/main/docs/user-guide.md)
2. Try the [Quick Start Tutorial](https://github.com/bacoco/aidesigner/blob/main/docs/quickstart.md)
3. Explore [Example Projects](https://github.com/bacoco/aidesigner/tree/main/examples)

### Next Steps
1. ✅ Run \`npm install\` to install dependencies
2. 🎯 Use **PM Agent** to create your first PRD
3. 🏗️ Use **Architect Agent** to design your system
4. 💻 Use **Dev Agent** to start building!

---

**Powered by AiDesigner** | BMAD-METHOD™ Framework
`;

    if (!fs.existsSync(readmePath)) {
      fs.writeFileSync(readmePath, readmeContent);
      console.log('✅ Created README.md with BMAD workflow guidance');
    } else {
      console.warn('⚠️ README.md already exists. Leaving existing content untouched.');
    }

    // Create .aidesigner/project.json metadata (.aidesigner directory already created earlier)
    const projectMetadataPath = path.join(projectRoot, '.aidesigner', 'project.json');
    const projectMetadata = {
      name: projectName,
      version: '1.0.0',
      aidesignerVersion: currentVersion,
      createdAt: new Date().toISOString(),
      config: {
        mcpServers: Object.keys(mcpConfig.mcpServers || {}).filter(
          (key) => !mcpConfig.mcpServers[key].disabled,
        ),
      },
    };

    if (!fs.existsSync(projectMetadataPath)) {
      fs.writeFileSync(projectMetadataPath, JSON.stringify(projectMetadata, null, 2) + '\n');
      console.log('✅ Created .aidesigner/project.json metadata');
    }

    console.log(`
✨ AiDesigner initialized successfully in: ${projectName}/

📋 Created Structure:
   ✓ README.md - BMAD workflow guide
   ✓ docs/ - Documentation directory with BMAD structure
   ✓ .aidesigner/ - Project metadata
   ✓ .mcp.json - MCP server configuration

🎯 BMAD Workflow Quick Start:

  Phase 1: Planning (Web UI Recommended)
  ----------------------------------------
  1. Use PM Agent to create PRD → docs/prd.md
  2. Use Architect Agent to design system → docs/architecture.md
  3. Use PO Agent to validate and shard documents

  Phase 2: Transition to IDE
  ---------------------------
  4. Copy generated docs to your project
  5. PO Agent shards into subdirectories

  Phase 3: Development (IDE)
  ---------------------------
  6. Use SM Agent to create stories → docs/stories/
  7. Use Dev Agent to implement features
  8. Use QA Agent to review and validate

📦 Next Steps:

  1. Install dependencies:
     cd ${projectName}
     npm install

  2. Read the README for detailed workflow:
     cat README.md

  3. Start development with your chosen agent:
     npm run aidesigner:codex    # Codex CLI
     npm run aidesigner:claude   # Claude chat

  4. Begin with PM Agent to create your PRD:
     "Use PM agent to create a PRD for [your project idea]"

📚 Resources:
   • README.md - Full BMAD workflow guide (in ${projectName}/)
   • https://github.com/bacoco/aidesigner - Complete documentation
   • Discord: https://discord.gg/aidesigner - Community support

Happy building with BMAD! 🚀
`);
  },

  codex: async () => {
    consumeLlmOptionsFromArgs();

    const localInstall = path.join(process.cwd(), 'node_modules', 'aidesigner');
    const codexScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'aidesigner-codex')
      : path.join(__dirname, 'aidesigner-codex');

    if (!fs.existsSync(codexScript)) {
      console.error('❌ AiDesigner not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx aidesigner init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [codexScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: buildSpawnEnv(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Codex CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  chat: async () => {
    consumeLlmOptionsFromArgs();

    // Check if aidesigner is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'aidesigner');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'aidesigner-claude')
      : path.join(__dirname, 'aidesigner-claude');

    if (!fs.existsSync(chatScript)) {
      console.error('❌ AiDesigner not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx aidesigner init && npm install');
      process.exit(1);
    }

    await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });

    // Merge runtime LLM flags with Anthropic-compatible GLM env when active
    const baseEnv = buildSpawnEnv();
    const { env: glmCompatEnv, isGlm } = buildAssistantSpawnEnv();
    const chatEnv = isGlm ? { ...baseEnv, ...glmCompatEnv } : baseEnv;

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: chatEnv,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Claude CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  opencode: async () => {
    consumeLlmOptionsFromArgs();

    // Ensure GLM credentials are configured if GLM provider is active
    await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });

    const { env: opencodeEnv, isGlm } = buildAssistantSpawnEnv();

    if (isGlm) {
      console.log('🌐 GLM mode active: routing OpenCode CLI through configured GLM endpoint.');
    }

    const child = spawn('opencode', args, {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: false,
      env: opencodeEnv,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch OpenCode CLI:', error.message);
      console.error('   Make sure OpenCode is installed and in your PATH.');
      console.error('   Visit: https://github.com/openchatai/opencode for installation instructions');
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  workflow: async () => {
    if (args.length === 0) {
      console.error('Usage: npx aidesigner workflow start <genesis|librarian|refactor>');
      process.exit(1);
    }

    const [action, workflowId] = args;
    if (action !== 'start') {
      console.error(`Unknown workflow action: ${action}. Only "start" is supported.`);
      process.exit(1);
    }

    const supported = new Set(['genesis', 'librarian', 'refactor']);
    if (!supported.has(workflowId)) {
      console.error('Unknown workflow id. Use one of: genesis, librarian, refactor.');
      process.exit(1);
    }

    const { MetaAgentWorkflowService } = require('../common/workflows/meta-agent-workflows.js');

    const parseList = (value, fallback = []) => {
      if (typeof value !== 'string' || value.trim() === '') {
        return fallback;
      }
      return value
        .split(',')
        .map((item) => item.trim())
        .filter((item) => item.length > 0);
    };

    const interactive = isInteractiveTerminal();
    let input;

    if (workflowId === 'genesis') {
      let answers = {
        projectName: 'new-project',
        projectType: 'Full-stack web app',
        technologyStack: 'React, FastAPI, Supabase',
      };
      if (interactive) {
        answers = await inquirer.prompt([
          {
            type: 'input',
            name: 'projectName',
            message: 'Project name',
            default: answers.projectName,
          },
          {
            type: 'input',
            name: 'projectType',
            message: 'Project type / focus',
            default: answers.projectType,
          },
          {
            type: 'input',
            name: 'technologyStack',
            message: 'Technology stack (comma separated)',
            default: answers.technologyStack,
          },
        ]);
      }

      input = {
        projectName: answers.projectName.trim() || 'new-project',
        projectType: answers.projectType.trim() || 'Full-stack web app',
        technologyStack: parseList(answers.technologyStack, ['React', 'FastAPI']),
      };
    } else if (workflowId === 'librarian') {
      let answers = {
        scopePaths: 'src',
        apiFiles: '',
        developmentGuidePath: 'DEVELOPMENT_GUIDE.md',
      };
      if (interactive) {
        answers = await inquirer.prompt([
          {
            type: 'input',
            name: 'scopePaths',
            message: 'Documentation scope directories (comma separated)',
            default: answers.scopePaths,
          },
          {
            type: 'input',
            name: 'apiFiles',
            message: 'API entry files (comma separated, optional)',
            default: answers.apiFiles,
          },
          {
            type: 'input',
            name: 'developmentGuidePath',
            message: 'Development guide path',
            default: answers.developmentGuidePath,
          },
        ]);
      }

      input = {
        scopePaths: parseList(answers.scopePaths, ['src']),
        apiFiles: parseList(answers.apiFiles),
        developmentGuidePath: answers.developmentGuidePath?.trim() || 'DEVELOPMENT_GUIDE.md',
      };
    } else {
      let answers = {
        scopePaths: 'src',
        dependencyFiles: 'package.json,requirements.txt',
      };
      if (interactive) {
        answers = await inquirer.prompt([
          {
            type: 'input',
            name: 'scopePaths',
            message: 'Directories to analyze for technical debt (comma separated)',
            default: answers.scopePaths,
          },
          {
            type: 'input',
            name: 'dependencyFiles',
            message: 'Dependency manifest files (comma separated)',
            default: answers.dependencyFiles,
          },
        ]);
      }

      input = {
        scopePaths: parseList(answers.scopePaths, ['src']),
        dependencyFiles: parseList(answers.dependencyFiles, ['package.json', 'requirements.txt']),
      };
    }

    const service = new MetaAgentWorkflowService({
      projectRoot: process.cwd(),
      fileSystem: undefined,
      supabaseClient: undefined,
      logger: (message) => {
        if (message) {
          console.log(message);
        }
      },
    });

    try {
      const { sessionId, result } = await service.start(workflowId, input);

      console.log(`\n✅ Workflow ${workflowId} completed (session ${sessionId}).`);
      console.log('\n📊 Stage Results:');
      for (const stage of result.stages) {
        const mark = stage.status === 'complete' ? '✔' : '…';
        console.log(`  ${mark} ${stage.title}`);
        if (stage.summary) {
          console.log(`    ↳ ${stage.summary}`);
        }
        for (const artifact of stage.artifacts ?? []) {
          console.log(`    • ${artifact.path} — ${artifact.description}`);
        }
      }

      console.log('\n📁 Artifacts saved:');
      if (!result.artifacts.length) {
        console.log('  (no artifacts recorded)');
      } else {
        for (const artifact of result.artifacts) {
          console.log(`  • ${artifact.path} — ${artifact.description}`);
        }
      }

      return result;
    } catch (error) {
      console.error(`\n❌ Workflow ${workflowId} failed:\n`);
      console.error(error.message);
      if (error.stack) {
        console.error('\nStack trace:');
        console.error(error.stack);
      }
      process.exit(1);
    }
  },

  install: async () => {
    console.log('📦 Installing AiDesigner globally...\n');

    const child = spawn('npm', ['install', '-g', 'aidesigner'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ AiDesigner installed globally!');
        console.log('You can now use: aidesigner <command>');
      }
      process.exit(code || 0);
    });
  },

  'companion-sync': async () => {
    const { config, path: configPath, error } = loadCompanionIntegrationConfig();
    if (!config) {
      console.error('❌ Unable to load compounding-engineering integration config.');
      if (error) {
        console.error(`   Path: ${configPath}`);
        console.error(`   Reason: ${error.message || error}`);
      }
      return;
    }

    const repoPath = resolveCompanionRepoPath(config);
    if (!repoPath) {
      console.error('❌ Invalid repository path in compounding-engineering configuration.');
      console.error('   Update packages/meta-agents/config/compounding-engineering.json with a repositoryPath value.');
      return;
    }

    const manifestPath = path.isAbsolute(config.manifestPath)
      ? config.manifestPath
      : path.join(repoPath, config.manifestPath);

    const cliPath = config?.defaultCommand?.args?.[0]
      ? path.join(repoPath, config.defaultCommand.args[0])
      : undefined;

    const manifestExists = manifestPath ? fs.existsSync(manifestPath) : false;
    const cliExists = cliPath ? fs.existsSync(cliPath) : false;

    console.log('🔎 Compounding Engineering integration status');
    console.log(`   Config: ${configPath}`);
    console.log(`   Repository root: ${repoPath}`);
    console.log(`   Manifest: ${manifestExists ? '✅ found' : '❌ missing'} (${manifestPath})`);
    console.log(`   CLI entry: ${cliExists ? '✅ found' : '❌ missing'} (${cliPath ?? 'n/a'})`);

    if (!manifestExists || !cliExists) {
      console.error('❌ Built-in planner assets are incomplete. Reinstall the package or restore missing files.');
      process.exitCode = 1;
      return;
    }

    console.log('✅ Built-in planner assets are ready. No external clone required.');
  },

  build: async () => {
    console.log('🔨 Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'aidesigner');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const packagedEntryCandidates = [
      path.join(rootDir, 'dist', 'mcp', 'mcp', 'server.js'),
      path.join(rootDir, 'dist', 'mcp', 'server.js'),
    ];
    const resolvedPackagedEntry = packagedEntryCandidates.find((candidate) =>
      fs.existsSync(candidate),
    );

    if (resolvedPackagedEntry) {
      console.log('✅ MCP server already built and ready!');
      console.log(`   Entry point: ${resolvedPackagedEntry}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        const builtEntry = packagedEntryCandidates.find((candidate) =>
          fs.existsSync(candidate),
        );
        console.log('\n✅ MCP server built successfully!');
        if (builtEntry) {
          console.log(`   Entry point: ${builtEntry}`);
        }
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  review: async () => {
    const includeResolved = args.includes('--include-resolved') || args.includes('--all');
    const projectRoot = process.cwd();

    const projectState = new ProjectState(projectRoot);
    await projectState.initialize();
    const queue = projectState.getDrawbridgeReviewQueue({ includeResolved });

    if (!queue || queue.length === 0) {
      console.log('✅ No Drawbridge annotations awaiting review.');
      return;
    }

    printDrawbridgeReviewQueue(queue, { includeResolved });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

const setRuntimeContext = (nextCommand, nextArgs = [], options = {}) => {
  command = nextCommand;
  args = Array.isArray(nextArgs) ? [...nextArgs] : [];
  runtimeOptions = { ...createDefaultRuntimeOptions(), ...(options.runtimeOptions || {}) };
};

const run = (argv = process.argv) => {
  runtimeOptions = createDefaultRuntimeOptions();
  [, , command, ...args] = argv;

  if (!command || command === '--help' || command === '-h') {
    printHelp();
    return Promise.resolve();
  }

  const handler = commands[command];
  if (!handler) {
    console.error(`❌ Unknown command: ${command}`);
    console.log('Run "npx aidesigner help" for usage information.');
    process.exit(1);
  }

  try {
    const result = handler();
    if (result && typeof result.then === 'function') {
      return result.catch((error) => {
        console.error('❌ Error:', error.message);
        process.exit(1);
      });
    }

    return Promise.resolve(result);
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
    return Promise.resolve();
  }
};

// Run integrity check only when executed directly (not when imported for testing)
// This ensures the CLI validates package integrity at runtime while allowing
// tests to import and mock functions without triggering validation
if (require.main === module) {
  // Skip integrity check during installation to avoid confusing warnings
  const skipIntegrityCheck = process.argv.includes('start') || process.argv.includes('init');
  if (!skipIntegrityCheck) {
    runIntegrityPreflight(packageRoot, { silentOnMatch: true });
  }

  run().catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  commands,
  determineAssistant,
  parseAssistantFromArgs,
  printHelp,
  run,
  runIntegrityPreflight,
  setRuntimeContext,
};
