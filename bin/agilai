#!/usr/bin/env node

/**
 * Agilai - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx agilai init
 *   npx agilai chat
 *   npx agilai install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const inquirer = require('inquirer');
const { runIntegrityPreflight } = require('../common/utils/integrity');
const { buildAssistantSpawnEnv } = require('../common/utils/assistant-env');

let command;
let args = [];
const packageRoot = path.join(__dirname, '..');

const CLAUDE_PROVIDER_ENV_KEYS = [
  'AGILAI_ASSISTANT_PROVIDER',
  'BMAD_ASSISTANT_PROVIDER',
  'CLAUDE_CLI_PROVIDER',
  'CLAUDE_CLI_DEFAULT_PROVIDER',
  'CLAUDE_DEFAULT_PROVIDER',
  'CLAUDE_PROVIDER',
  'CLAUDE_CODE_PROVIDER',
];

const GLM_API_KEY_ENV_KEYS = ['AGILAI_GLM_API_KEY', 'BMAD_GLM_API_KEY', 'GLM_API_KEY', 'ZHIPUAI_API_KEY'];
const GLM_BASE_URL_ENV_KEYS = ['AGILAI_GLM_BASE_URL', 'BMAD_GLM_BASE_URL', 'GLM_BASE_URL'];
const GLM_AUTH_TOKEN_ENV_KEYS = ['AGILAI_GLM_AUTH_TOKEN', 'BMAD_GLM_AUTH_TOKEN', 'GLM_AUTH_TOKEN'];

const hasOwn = (source, key) => Boolean(source && Object.prototype.hasOwnProperty.call(source, key));

/**
 * Resolves environment variable value from a prioritized list of keys
 * @param {Object} source - Environment object to search (e.g., process.env or parsed .env file)
 * @param {string[]} keys - Array of keys in priority order (first match wins)
 * @returns {{key: string|undefined, value: string|undefined}} The matched key and its trimmed value
 */
const resolveEnvValue = (source, keys) => {
  for (const key of keys) {
    const value = source?.[key];
    if (typeof value === 'string' && value.trim()) {
      return { key, value: value.trim() };
    }
  }

  return { key: undefined, value: undefined };
};

/**
 * Chooses which environment variable key to use for writing
 * Returns the first existing key from the source, or the first key if none exist
 * @param {Object} source - Environment object to check (e.g., parsed .env file)
 * @param {string[]} keys - Array of keys in priority order
 * @returns {string} The key to use for writing
 */
const chooseWriteKey = (source, keys) => {
  for (const key of keys) {
    if (hasOwn(source, key)) {
      return key;
    }
  }

  return keys[0];
};

/**
 * Sets a process environment variable only if it's not already set or is empty/whitespace
 * @param {string} key - The environment variable name
 * @param {string|undefined} value - The value to set (ignored if falsy or whitespace-only)
 */
const setProcessEnvIfMissing = (key, value) => {
  if (!value || (typeof value === 'string' && value.trim() === '')) {
    return;
  }

  if (typeof process.env[key] !== 'string' || process.env[key].trim() === '') {
    process.env[key] = value;
  }
};

const parseEnvFile = (filePath) => {
  const parsed = {};
  const raw = fs.readFileSync(filePath, 'utf8');
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    const equalsIndex = trimmed.indexOf('=');
    if (equalsIndex === -1) {
      continue;
    }

    let key = trimmed.slice(0, equalsIndex).trim();
    if (key.startsWith('export ')) {
      key = key.slice('export '.length).trim();
    }

    if (!key) {
      continue;
    }

    let value = trimmed.slice(equalsIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    // Validate that value doesn't contain newlines (would break .env format)
    if (value.includes('\n') || value.includes('\r')) {
      console.warn(`‚ö†Ô∏è Skipping invalid .env value for ${key}: contains newline characters`);
      continue;
    }

    parsed[key] = value;
  }

  return parsed;
};

const readProjectEnv = (projectRoot) => {
  const envPath = path.join(projectRoot, '.env');
  if (!fs.existsSync(envPath)) {
    return { values: {}, path: envPath };
  }

  try {
    return { values: parseEnvFile(envPath), path: envPath };
  } catch (error) {
    console.warn(
      `‚ö†Ô∏è Unable to parse ${envPath}: ${error.message || error}. Continuing without it.`,
    );
    return { values: {}, path: envPath };
  }
};

const isInteractiveTerminal = () => Boolean(process.stdin.isTTY && process.stdout.isTTY);

/**
 * Parses provider from CLI arguments.
 * Precedence: CLI args > process env vars > .env file > interactive prompts
 */
const parseProviderFromArgs = (cliArgs = []) => {
  for (let index = 0; index < cliArgs.length; index += 1) {
    const arg = cliArgs[index];

    if (arg === '--provider' || arg.startsWith('--provider=')) {
      const value = arg === '--provider' ? cliArgs[index + 1] : arg.split('=')[1];
      if (value && typeof value === 'string' && value.trim()) {
        return value.trim().toLowerCase();
      }
    }
  }

  return undefined;
};

const determineClaudeProvider = (cliArgs = [], envFromFile = {}) => {
  const fromArgs = parseProviderFromArgs(cliArgs);
  if (fromArgs) {
    return fromArgs;
  }

  for (const key of CLAUDE_PROVIDER_ENV_KEYS) {
    const value = process.env[key] || envFromFile[key];
    if (typeof value === 'string' && value.trim()) {
      return value.trim().toLowerCase();
    }
  }

  return undefined;
};

const promptForInput = (question) =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    // Timeout after 5 minutes to prevent hanging
    const timeout = setTimeout(() => {
      cleanup();
      reject(new Error('Input prompt timed out after 5 minutes'));
    }, 300000);

    rl.on('error', (error) => {
      clearTimeout(timeout);
      cleanup();
      reject(error);
    });

    rl.question(question, (answer) => {
      clearTimeout(timeout);
      cleanup();
      resolve(answer);
    });
  });

const promptForGlmCredentials = async ({ existingBaseUrl } = {}) => {
  console.log('üîê GLM provider selected. A Z.AI API token is required.');

  let apiKey;
  while (!apiKey) {
    // eslint-disable-next-line no-await-in-loop
    const input = await promptForInput('Enter your Z.AI GLM API token: ');
    const trimmed = (input || '').trim();
    if (trimmed) {
      apiKey = trimmed;
    } else {
      console.log('‚ö†Ô∏è Token cannot be empty. Please provide a valid value.');
    }
  }

  const baseUrlPrompt = existingBaseUrl
    ? `Enter a custom GLM base URL (leave blank to keep ${existingBaseUrl}): `
    : 'Enter a custom GLM base URL (leave blank for the CLI default): ';
  const baseUrlInput = await promptForInput(baseUrlPrompt);
  const baseUrl = (baseUrlInput || '').trim();

  return { apiKey, baseUrl: baseUrl || undefined };
};

const promptToPersistGlmEnv = async () => {
  if (!isInteractiveTerminal()) {
    return false;
  }

  try {
    const answer = await promptForInput(
      'Would you like to save these GLM credentials to .env for future runs? (y/N): ',
    );
    const normalized = (answer || '').trim().toLowerCase();
    return normalized === 'y' || normalized === 'yes';
  } catch (error) {
    console.warn(
      `‚ö†Ô∏è Skipping persistence prompt due to an input error: ${error.message || error}`,
    );
    return false;
  }
};

const persistEnvValues = (envPath, updates) => {
  const normalizedUpdates = Object.entries(updates).reduce((acc, [key, value]) => {
    if (typeof value === 'string' && value) {
      // Validate no newlines in values
      if (value.includes('\n') || value.includes('\r')) {
        console.warn(`‚ö†Ô∏è Skipping ${key}: value contains newline characters`);
        return acc;
      }
      acc[key] = value;
    }
    return acc;
  }, {});

  const updateKeys = Object.keys(normalizedUpdates);
  if (updateKeys.length === 0) {
    return;
  }

  let lines = [];
  if (fs.existsSync(envPath)) {
    lines = fs.readFileSync(envPath, 'utf8').split(/\r?\n/);
  }

  const seenKeys = new Set();
  const updatedLines = lines.map((line) => {
    const match = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=(.*)$/);
    if (!match) {
      return line;
    }

    const key = match[1];
    if (Object.prototype.hasOwnProperty.call(normalizedUpdates, key)) {
      seenKeys.add(key);
      return `${key}=${normalizedUpdates[key]}`;
    }

    return line;
  });

  for (const key of updateKeys) {
    if (!seenKeys.has(key)) {
      updatedLines.push(`${key}=${normalizedUpdates[key]}`);
    }
  }

  const finalContent = updatedLines.join('\n') + '\n';

  fs.writeFileSync(envPath, finalContent);
  console.log('‚ö†Ô∏è  WARNING: Keep this file secure and never commit it to version control.');
};

const ensureClaudeEnvironment = async ({ projectRoot, userArgs = [] }) => {
  const { values: fileEnv, path: envPath } = readProjectEnv(projectRoot);

  const anthropicToken = process.env.ANTHROPIC_AUTH_TOKEN || fileEnv.ANTHROPIC_AUTH_TOKEN;
  if (anthropicToken && !process.env.ANTHROPIC_AUTH_TOKEN) {
    process.env.ANTHROPIC_AUTH_TOKEN = anthropicToken;
  }

  const processApiKey = resolveEnvValue(process.env, GLM_API_KEY_ENV_KEYS);
  const fileApiKey = resolveEnvValue(fileEnv, GLM_API_KEY_ENV_KEYS);
  const processBaseUrl = resolveEnvValue(process.env, GLM_BASE_URL_ENV_KEYS);
  const fileBaseUrl = resolveEnvValue(fileEnv, GLM_BASE_URL_ENV_KEYS);
  const processAuthToken = resolveEnvValue(process.env, GLM_AUTH_TOKEN_ENV_KEYS);
  const fileAuthToken = resolveEnvValue(fileEnv, GLM_AUTH_TOKEN_ENV_KEYS);

  const glmApiKey = processApiKey.value || fileApiKey.value;
  const glmBaseUrl = processBaseUrl.value || fileBaseUrl.value;
  const glmAuthToken = processAuthToken.value || fileAuthToken.value;

  if (!processApiKey.value && fileApiKey.value) {
    setProcessEnvIfMissing(fileApiKey.key, fileApiKey.value);
  }

  if (!processBaseUrl.value && fileBaseUrl.value) {
    setProcessEnvIfMissing(fileBaseUrl.key, fileBaseUrl.value);
  }

  if (!processAuthToken.value && fileAuthToken.value) {
    setProcessEnvIfMissing(fileAuthToken.key, fileAuthToken.value);
  }

  setProcessEnvIfMissing('AGILAI_GLM_API_KEY', glmApiKey);
  setProcessEnvIfMissing('AGILAI_GLM_BASE_URL', glmBaseUrl);
  setProcessEnvIfMissing('AGILAI_GLM_AUTH_TOKEN', glmAuthToken);

  const legacyBmadApiKeyDetected = Boolean(process.env.BMAD_GLM_API_KEY || hasOwn(fileEnv, 'BMAD_GLM_API_KEY'));
  const legacyBmadBaseDetected = Boolean(process.env.BMAD_GLM_BASE_URL || hasOwn(fileEnv, 'BMAD_GLM_BASE_URL'));
  const legacyBmadAuthDetected = Boolean(process.env.BMAD_GLM_AUTH_TOKEN || hasOwn(fileEnv, 'BMAD_GLM_AUTH_TOKEN'));
  const legacyGlmApiKeyDetected = Boolean(process.env.GLM_API_KEY || hasOwn(fileEnv, 'GLM_API_KEY'));
  const legacyGlmBaseDetected = Boolean(process.env.GLM_BASE_URL || hasOwn(fileEnv, 'GLM_BASE_URL'));
  const legacyGlmAuthDetected = Boolean(process.env.GLM_AUTH_TOKEN || hasOwn(fileEnv, 'GLM_AUTH_TOKEN'));
  const legacyZhipuKeyDetected = Boolean(process.env.ZHIPUAI_API_KEY || hasOwn(fileEnv, 'ZHIPUAI_API_KEY'));

  if (legacyGlmApiKeyDetected) {
    setProcessEnvIfMissing('GLM_API_KEY', glmApiKey);
  }

  if (legacyGlmBaseDetected) {
    setProcessEnvIfMissing('GLM_BASE_URL', glmBaseUrl);
  }

  if (legacyGlmAuthDetected) {
    setProcessEnvIfMissing('GLM_AUTH_TOKEN', glmAuthToken);
  }

  if (legacyBmadApiKeyDetected) {
    setProcessEnvIfMissing('BMAD_GLM_API_KEY', glmApiKey);
  }

  if (legacyBmadBaseDetected) {
    setProcessEnvIfMissing('BMAD_GLM_BASE_URL', glmBaseUrl);
  }

  if (legacyBmadAuthDetected) {
    setProcessEnvIfMissing('BMAD_GLM_AUTH_TOKEN', glmAuthToken);
  }

  if (legacyZhipuKeyDetected) {
    setProcessEnvIfMissing('ZHIPUAI_API_KEY', glmApiKey);
  }

  const provider = determineClaudeProvider(userArgs, fileEnv);
  if (provider !== 'glm') {
    return;
  }

  const effectiveBaseUrl = glmBaseUrl;

  if (glmApiKey) {
    return;
  }

  if (!isInteractiveTerminal()) {
    console.error('‚ùå GLM provider selected but no GLM API key is configured.');
    console.error(
      '   Provide AGILAI_GLM_API_KEY (or legacy GLM_API_KEY / BMAD_GLM_API_KEY) and optional AGILAI_GLM_BASE_URL before running in non-interactive mode.',
    );
    process.exit(1);
  }

  let credentials;
  try {
    credentials = await promptForGlmCredentials({ existingBaseUrl: effectiveBaseUrl });
  } catch (error) {
    console.error('‚ùå Failed to read GLM credentials:', error.message || error);
    process.exit(1);
  }

  process.env.AGILAI_GLM_API_KEY = credentials.apiKey;
  if (legacyGlmApiKeyDetected && !process.env.GLM_API_KEY) {
    process.env.GLM_API_KEY = credentials.apiKey;
  }
  if (legacyBmadApiKeyDetected && !process.env.BMAD_GLM_API_KEY) {
    process.env.BMAD_GLM_API_KEY = credentials.apiKey;
  }
  if (legacyZhipuKeyDetected && !process.env.ZHIPUAI_API_KEY) {
    process.env.ZHIPUAI_API_KEY = credentials.apiKey;
  }

  if (credentials.baseUrl) {
    process.env.AGILAI_GLM_BASE_URL = credentials.baseUrl;
    if (legacyGlmBaseDetected && !process.env.GLM_BASE_URL) {
      process.env.GLM_BASE_URL = credentials.baseUrl;
    }
    if (legacyBmadBaseDetected && !process.env.BMAD_GLM_BASE_URL) {
      process.env.BMAD_GLM_BASE_URL = credentials.baseUrl;
    }
  } else if (effectiveBaseUrl) {
    setProcessEnvIfMissing('AGILAI_GLM_BASE_URL', effectiveBaseUrl);
    if (legacyGlmBaseDetected) {
      setProcessEnvIfMissing('GLM_BASE_URL', effectiveBaseUrl);
    }
    if (legacyBmadBaseDetected) {
      setProcessEnvIfMissing('BMAD_GLM_BASE_URL', effectiveBaseUrl);
    }
  }

  if (glmAuthToken) {
    setProcessEnvIfMissing('AGILAI_GLM_AUTH_TOKEN', glmAuthToken);
  }

  const shouldPersist = await promptToPersistGlmEnv();
  if (!shouldPersist) {
    console.log('‚ÑπÔ∏è Skipped saving GLM credentials to .env.');
    return;
  }

  const updates = {};
  updates[chooseWriteKey(fileEnv, GLM_API_KEY_ENV_KEYS)] = credentials.apiKey;
  const baseToPersist = credentials.baseUrl || effectiveBaseUrl;
  if (baseToPersist) {
    updates[chooseWriteKey(fileEnv, GLM_BASE_URL_ENV_KEYS)] = baseToPersist;
  }

  try {
    persistEnvValues(envPath, updates);
    const relativeEnvPath = path.relative(process.cwd(), envPath) || '.env';
    console.log(`üíæ Saved GLM credentials to ${relativeEnvPath}`);
  } catch (error) {
    console.warn(`‚ö†Ô∏è Unable to persist GLM credentials: ${error.message || error}`);
  }
};

const createDefaultRuntimeOptions = () => ({
  llmProvider: undefined,
  llmModel: undefined,
});

let runtimeOptions = createDefaultRuntimeOptions();

const VALID_LLM_PROVIDERS = new Set(['claude', 'glm', 'openai', 'gpt', 'gemini', 'google']);

const normalizeLlmProvider = (value) => {
  if (!value) {
    return undefined;
  }

  const normalized = value.toLowerCase();

  if (normalized === 'anthropic') {
    return 'claude';
  }

  if (normalized === 'zhipu') {
    return 'glm';
  }

  return normalized;
};

const parseLlmOptionsFromArgs = (currentArgs) => {
  let provider;
  let model;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--glm') {
      provider = 'glm';
      continue;
    }

    if (arg === '--anthropic') {
      provider = 'claude';
      continue;
    }

    if (arg === '--llm-provider') {
      provider = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-provider=')) {
      provider = arg.split('=')[1];
      continue;
    }

    if (arg === '--llm-model') {
      model = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-model=')) {
      model = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  return { provider: normalizeLlmProvider(provider), model, sanitized };
};

const consumeLlmOptionsFromArgs = () => {
  if (!args.length) {
    return;
  }

  const { provider, model, sanitized } = parseLlmOptionsFromArgs(args);
  args.splice(0, args.length, ...sanitized);

  if (provider) {
    if (!VALID_LLM_PROVIDERS.has(provider)) {
      console.error('‚ö†Ô∏è Unsupported LLM provider flag value:', provider);
      console.error('Valid providers:', Array.from(VALID_LLM_PROVIDERS).join(', '));
      process.exit(1);
      return;
    }

    runtimeOptions.llmProvider = provider;
  }

  if (model) {
    runtimeOptions.llmModel = model;
  }
};

const buildSpawnEnv = () => {
  const env = { ...process.env };
  const legacyBmadProviderDetected = typeof process.env.BMAD_ASSISTANT_PROVIDER === 'string';
  const legacyBmadApiKeyDetected = typeof process.env.BMAD_GLM_API_KEY === 'string';
  const legacyBmadBaseDetected = typeof process.env.BMAD_GLM_BASE_URL === 'string';
  const legacyBmadAuthDetected = typeof process.env.BMAD_GLM_AUTH_TOKEN === 'string';
  const legacyGlmApiKeyDetected = typeof process.env.GLM_API_KEY === 'string';
  const legacyGlmBaseDetected = typeof process.env.GLM_BASE_URL === 'string';
  const legacyGlmAuthDetected = typeof process.env.GLM_AUTH_TOKEN === 'string';
  const legacyZhipuKeyDetected = typeof process.env.ZHIPUAI_API_KEY === 'string';

  if (runtimeOptions.llmProvider) {
    env.LLM_PROVIDER = runtimeOptions.llmProvider;
    env.AGILAI_ASSISTANT_PROVIDER = runtimeOptions.llmProvider;

    if (legacyBmadProviderDetected) {
      env.BMAD_ASSISTANT_PROVIDER = runtimeOptions.llmProvider;
    } else if (env.BMAD_ASSISTANT_PROVIDER === 'glm') {
      delete env.BMAD_ASSISTANT_PROVIDER;
    }

    if (runtimeOptions.llmProvider === 'glm') {
      const existingKey =
        env.AGILAI_GLM_API_KEY || env.BMAD_GLM_API_KEY || env.GLM_API_KEY || env.ZHIPUAI_API_KEY;
      const existingBase =
        env.AGILAI_GLM_BASE_URL || env.BMAD_GLM_BASE_URL || env.GLM_BASE_URL;
      const existingAuth =
        env.AGILAI_GLM_AUTH_TOKEN || env.BMAD_GLM_AUTH_TOKEN || env.GLM_AUTH_TOKEN;

      if (existingKey && !env.AGILAI_GLM_API_KEY) {
        env.AGILAI_GLM_API_KEY = existingKey;
      }
      if (existingBase && !env.AGILAI_GLM_BASE_URL) {
        env.AGILAI_GLM_BASE_URL = existingBase;
      }
      if (existingAuth && !env.AGILAI_GLM_AUTH_TOKEN) {
        env.AGILAI_GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyGlmApiKeyDetected && !env.GLM_API_KEY && existingKey) {
        env.GLM_API_KEY = existingKey;
      }
      if (legacyGlmBaseDetected && !env.GLM_BASE_URL && existingBase) {
        env.GLM_BASE_URL = existingBase;
      }
      if (legacyGlmAuthDetected && !env.GLM_AUTH_TOKEN && existingAuth) {
        env.GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyBmadApiKeyDetected && !env.BMAD_GLM_API_KEY && existingKey) {
        env.BMAD_GLM_API_KEY = existingKey;
      }
      if (legacyBmadBaseDetected && !env.BMAD_GLM_BASE_URL && existingBase) {
        env.BMAD_GLM_BASE_URL = existingBase;
      }
      if (legacyBmadAuthDetected && !env.BMAD_GLM_AUTH_TOKEN && existingAuth) {
        env.BMAD_GLM_AUTH_TOKEN = existingAuth;
      }

      // Always set ZHIPUAI_API_KEY for GLM mode if we have a key
      if (existingKey && !env.ZHIPUAI_API_KEY) {
        env.ZHIPUAI_API_KEY = existingKey;
      }
    }
  }

  if (runtimeOptions.llmModel) {
    env.LLM_MODEL = runtimeOptions.llmModel;
  }

  return env;
};

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;

const printHelp = () => {
  console.log(`
Agilai - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx agilai@latest <command> [options]

Options:
  --assistant=<assistant>    Launch specified CLI front-end (claude, codex, opencode)
  --llm-provider=<provider>  Override orchestrator LLM (claude, glm, openai, gemini)
  --llm-model=<model>        Force a specific model id for the orchestrator
  --glm                      Shortcut for --llm-provider=glm (uses ZHIPUAI_API_KEY)
  --anthropic                Shortcut for --llm-provider=claude

Commands:

  start                üöÄ ONE-COMMAND SETUP: init + install + prompt for assistant choice
  init                 Initialize Agilai in current project
  chat                 Start conversational interface with Claude CLI (Anthropic/GLM)
  codex                Start conversational interface with Codex CLI
  opencode             Start conversational interface with OpenCode CLI

  install              Install Agilai globally
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  help                 Show this help message

Examples:

  npx agilai@latest start      # üöÄ Do everything in one command!

  # Claude CLI (supports: anthropic, glm)
  npx agilai@latest start --assistant=claude --provider=glm
                                      # Launch Claude CLI with GLM API
  npx agilai@latest start --assistant=claude-glm
                                      # Combined flag also supported

  # Codex CLI (supports: openai only)
  npx agilai@latest start --assistant=codex --provider=openai
                                      # Launch Codex CLI with OpenAI/GPT

  # OpenCode CLI (supports: anthropic, glm, openai, gemini)
  npx agilai@latest start --assistant=opencode --provider=glm
                                      # Launch OpenCode with GLM API

  npx agilai@latest start --glm
                                      # Use GLM with AGILAI_GLM_API_KEY (preferred)
  npx agilai@latest init       # Setup in current project
  npm run codex                        # Start conversation (after install)


Flags:
  Use --assistant and optionally --provider to skip prompts. Combine values like
  --assistant=claude-glm when preferred.


üí° Tip: Always use @latest to get the newest version:
   npx agilai@latest start

Environment:
  Set AGILAI_GLM_API_KEY (preferred) or legacy GLM_API_KEY/ZHIPUAI_API_KEY and optionally LLM_MODEL when using --glm.
  Use --anthropic or LLM_PROVIDER=claude to switch back to Anthropic defaults.

For more information: https://github.com/bacoco/Agilai
`);
};

const ASSISTANT_CHOICES = [
  {
    id: 'claude',
    providers: ['anthropic', 'glm'], // Claude CLI only supports Anthropic and GLM APIs
  },
  {
    id: 'codex',
    providers: ['openai'], // Codex CLI only supports OpenAI/GPT models
  },
  {
    id: 'opencode',
    providers: ['anthropic', 'glm', 'openai', 'gemini'], // OpenCode supports all providers
  },
];

const findAssistantChoice = (id) =>
  ASSISTANT_CHOICES.find((choice) => choice.id === id);

const listAssistantIds = () => ASSISTANT_CHOICES.map(({ id }) => id);

const splitAssistantAndProvider = (value) => {
  if (!value) {
    return { assistant: undefined, provider: undefined };
  }

  const normalized = value.toLowerCase();
  const [assistantPart, ...providerParts] = normalized.split('-');
  const provider = providerParts.length > 0 ? providerParts.join('-') : undefined;

  return {
    assistant: assistantPart,
    provider,
  };
};

const OPTIONAL_MCP_SERVERS = [
  {
    id: 'github',
    label: 'GitHub repository operations',
    description: 'Git operations and GitHub API via MCP.',
    recommended: true,
    needsEnvPrompt: true,
    envKey: 'GITHUB_PERSONAL_ACCESS_TOKEN',
    envPrompt: 'Enter your GitHub Personal Access Token (or leave blank to skip)',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-github'],
      disabled: false,
    },
  },
  {
    id: 'chrome-devtools',
    label: 'Chrome DevTools bridge',
    description: 'Inspect and control active Chrome tabs via the DevTools protocol. Requires Chrome.',
    recommended: false,
    config: {
      command: 'npx',
      args: ['-y', 'chrome-devtools-mcp', '--headless'],
      disabled: false,
    },
  },
  {
    id: 'shadcn-ui',
    label: 'shadcn/ui component generator',
    description: 'Generate UI components from the shadcn library.',
    recommended: false,
    config: {
      command: 'npx',
      args: ['-y', '@jpisnice/shadcn-ui-mcp-server'],
      disabled: false,
    },
  },
];

const formatAssistantName = (value) =>
  value.charAt(0).toUpperCase() + value.slice(1);

const parseAssistantFromArgs = (currentArgs) => {
  let assistant;
  let provider;
  let providerExplicit = false;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--assistant') {
      assistant = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--assistant=')) {
      assistant = arg.split('=')[1];
      continue;
    }

    if (arg === '--provider') {
      provider = currentArgs[index + 1];
      index += 1;
      providerExplicit = true;
      continue;
    }

    if (arg.startsWith('--provider=')) {
      provider = arg.split('=')[1];
      providerExplicit = true;
      continue;
    }

    sanitized.push(arg);
  }

  if (assistant) {
    const { assistant: parsedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistant);
    assistant = parsedAssistant;
    if (!provider && combinedProvider) {
      provider = combinedProvider;
      providerExplicit = true;
    }
  }

  return {
    assistant: assistant ? assistant.toLowerCase() : undefined,
    provider: provider ? provider.toLowerCase() : undefined,
    providerExplicit,
    sanitized,
  };
};

/**
 * Provider label and description mappings for interactive selection
 */
const PROVIDER_LABELS = {
  anthropic: 'Anthropic',
  glm: 'GLM',
  openai: 'OpenAI',
  gemini: 'Gemini'
};

const PROVIDER_DESCRIPTIONS = {
  anthropic: 'Advanced reasoning and coding',
  glm: 'Chinese language excellence',
  openai: 'General purpose AI',
  gemini: 'Multimodal capabilities'
};

const promptForAssistant = async () => {
  if (!isInteractiveTerminal()) {
    console.error('‚ö†Ô∏è Interactive mode requires a TTY terminal');
    return undefined;
  }

  try {
    // Build all valid CLI-provider combinations
    const choices = [];
    for (const choice of ASSISTANT_CHOICES) {
      for (const provider of choice.providers) {
        const cliName = formatAssistantName(choice.id) + ' CLI';
        const providerLabel = PROVIDER_LABELS[provider];
        const description = PROVIDER_DESCRIPTIONS[provider];

        choices.push({
          name: `${cliName} ‚Üí ${providerLabel} - ${description}`,
          value: { assistant: choice.id, provider },
          short: `${cliName} ‚Üí ${providerLabel}`
        });
      }
    }

    const { selection } = await inquirer.prompt([{
      type: 'list',
      name: 'selection',
      message: 'Select CLI and provider:',
      choices,
      default: { assistant: 'claude', provider: 'anthropic' }
    }]);

    return {
      assistant: selection.assistant,
      provider: selection.provider,
      providerExplicit: true
    };
  } catch (error) {
    console.warn('‚ö†Ô∏è Selection cancelled or failed:', error.message || error);
    return undefined;
  }
};

const determineAssistant = async (input = {}) => {
  if (typeof input === 'string' || input === undefined) {
    return determineAssistant({ assistant: input });
  }

  const { assistant: assistantFlag, provider: providerFlag, providerExplicit: providerExplicitFromInput } = input;
  if (assistantFlag) {
    const { assistant: normalizedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistantFlag);
    let provider = providerFlag || combinedProvider;
    let providerExplicit =
      Boolean(providerFlag) || (combinedProvider ? providerExplicitFromInput !== false : false);
    const choice = findAssistantChoice(normalizedAssistant);

    if (!choice) {
      console.error('‚ö†Ô∏è Unsupported assistant flag value:', assistantFlag);
      console.error('Valid options:', listAssistantIds().join(', '));
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (provider && !choice.providers.includes(provider)) {
      console.error(
        `‚ö†Ô∏è Unsupported provider "${provider}" for ${normalizedAssistant} CLI.`,
      );
      console.error(
        `   Supported providers for ${normalizedAssistant}: ${choice.providers.join(', ')}`,
      );
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (!provider) {
      [provider] = choice.providers;
      providerExplicit = false;
    }

    return { assistant: choice.id, provider, providerExplicit };
  }

  if (!process.stdout.isTTY) {
    console.error(
      '‚ö†Ô∏è Non-interactive mode requires --assistant flag. Use: --assistant=claude, --assistant=claude-glm, or combine with --provider.',
    );
    process.exit(1);
    return; // For testing when exit is mocked
  }

  return promptForAssistant();
};

/**
 * Prompts user to select MCP servers using interactive checkbox
 * @returns {Promise<string[]>} Array of selected server IDs
 */
const promptForMcpServers = async () => {
  if (!isInteractiveTerminal()) {
    return [];
  }

  try {
    const choices = OPTIONAL_MCP_SERVERS.map(server => ({
      name: `${server.label} ‚Äî ${server.description}`,
      value: server.id,
      short: server.label,
      checked: server.recommended || false
    }));

    const { servers } = await inquirer.prompt([{
      type: 'checkbox',
      name: 'servers',
      message: 'Select MCP servers to enable (Space to toggle, Enter to confirm):',
      choices,
      pageSize: 10
    }]);

    return servers;
  } catch (error) {
    console.warn('‚ö†Ô∏è MCP server selection cancelled or failed:', error.message || error);
    return [];
  }
};

// Command handlers
const commands = {
  start: async () => {
    console.log('üöÄ Starting Agilai setup...\n');

    consumeLlmOptionsFromArgs();

    // Determine assistant preference before installation begins
    const {
      assistant: assistantFlag,
      provider: providerFlag,
      providerExplicit,
      sanitized,
    } = parseAssistantFromArgs(args);
    args.splice(0, args.length, ...sanitized);
    const selection = await determineAssistant({
      assistant: assistantFlag,
      provider: providerFlag,
      providerExplicit,
    });

    // If selection is undefined, exit was called (possibly mocked in tests)
    if (!selection) {
      return;
    }

      const {
        assistant,
        provider,
        providerExplicit: providerWasExplicit,
      } = selection;
      const choice = findAssistantChoice(assistant);
      let resolvedProvider = provider;

    // Override provider to GLM when --glm flag is used, the assistant supports GLM,
    // and the user didn't explicitly select a different provider via --provider flag
    if (
      runtimeOptions.llmProvider === 'glm' &&
      choice?.providers.includes('glm') &&
      resolvedProvider !== 'glm' &&
        !providerWasExplicit
      ) {
        resolvedProvider = 'glm';
      }

    process.env.AGILAI_ASSISTANT_PROVIDER = resolvedProvider;
    if (process.env.BMAD_ASSISTANT_PROVIDER) {
      process.env.BMAD_ASSISTANT_PROVIDER = resolvedProvider;
    }

    if (process.stdout.isTTY) {
      console.log(
        'üí° We can optionally enable additional MCP servers (chrome-devtools, shadcn) during setup.',
      );
    }

    // Run init
    await commands.init();

    // Run npm install
    console.log('\nüì¶ Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    const assistantName = formatAssistantName(assistant);
    const providerLabel = resolvedProvider ? ` (${resolvedProvider})` : '';
    console.log(
      `\nüéØ Starting Agilai Orchestrator with ${assistantName}${providerLabel}...\n`,
    );

    if (assistant === 'claude') {
      await commands.chat();
      return;
    }

    if (assistant === 'opencode') {
      await commands.opencode();
      return;
    }

    await commands.codex();
  },

  init: async () => {
    console.log('üöÄ Initializing Agilai...\n');

    let projectName;
    let projectRoot;

    // Interactive project name prompt
    if (isInteractiveTerminal()) {
      const { name } = await inquirer.prompt([{
        type: 'input',
        name: 'name',
        message: 'üìÅ What is your project name?',
        default: 'my-project',
        validate: (input) => {
          if (!input || input.trim() === '') {
            return 'Project name cannot be empty';
          }
          if (!/^[a-zA-Z0-9-_]+$/.test(input)) {
            return 'Project name can only contain letters, numbers, hyphens, and underscores';
          }
          return true;
        }
      }]);

      projectName = name;
      projectRoot = path.join(process.cwd(), projectName);
    } else {
      // Non-interactive: use current directory name
      projectName = path.basename(process.cwd());
      projectRoot = process.cwd();
    }

    console.log(`\nüéØ Initializing project: ${projectName}\n`);

    // Create and enter project directory (interactive mode only)
    if (isInteractiveTerminal() && projectRoot !== process.cwd()) {
      if (fs.existsSync(projectRoot)) {
        const { overwrite } = await inquirer.prompt([{
          type: 'confirm',
          name: 'overwrite',
          message: `Directory "${projectName}" already exists. Initialize Agilai here?`,
          default: true
        }]);

        if (!overwrite) {
          console.log('‚ùå Initialization cancelled');
          return;
        }
      } else {
        fs.mkdirSync(projectRoot, { recursive: true });
        console.log(`‚úÖ Created project directory: ${projectName}`);
      }

      process.chdir(projectRoot);
      console.log(`üìÇ Working in: ${projectRoot}\n`);
    } else {
      projectRoot = process.cwd();
    }

    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('üì¶ Creating package.json...');
      const defaultPackage = {
        name: projectName,
        version: '1.0.0',
        description: 'Project powered by Agilai',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('‚úÖ Created package.json');
    }

    // Create .agilai directory
    const agilaiDir = path.join(projectRoot, '.agilai');
    if (!fs.existsSync(agilaiDir)) {
      fs.mkdirSync(agilaiDir, { recursive: true });
      console.log('‚úÖ Created .agilai directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('‚úÖ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    // Use .mcp.json in project root for better Claude CLI compatibility
    const mcpConfigDest = path.join(projectRoot, '.mcp.json');
    let mcpConfig = { mcpServers: {} };
    let hadExistingMcpConfig = false;
    if (fs.existsSync(mcpConfigDest)) {
      try {
        const parsed = JSON.parse(fs.readFileSync(mcpConfigDest, 'utf8'));
        if (parsed && typeof parsed === 'object' && parsed.mcpServers) {
          // Preserve all top-level keys (logging, environment, etc.), not just mcpServers
          mcpConfig = { ...parsed };
          mcpConfig.mcpServers = { ...parsed.mcpServers };
          hadExistingMcpConfig = true;
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to parse existing MCP configuration. Rebuilding from defaults.');
      }
    }

    const orchestratorKey = 'agilai';
    const legacyOrchestratorKey = 'agilai-invisible-orchestrator';
    const orchestratorArgs = ['node_modules/agilai/dist/mcp/mcp/server.js'];
    const legacyOrchestratorArgs = new Set([
      'dist/mcp/mcp/server.js',
      './node_modules/agilai/dist/mcp/mcp/server.js',
      "require('agilai/dist/mcp/mcp/server.js')",
      "require('agilai/.dev/dist/mcp/mcp/server.js')",
    ]);
    const orchestratorConfig = {
      command: 'node',
      args: ['node_modules/agilai/dist/mcp/mcp/server.js'],
      disabled: false,
    };

    // Remove legacy key if present, preserving any custom configuration
    if (mcpConfig.mcpServers[legacyOrchestratorKey]) {
      const legacyConfig = mcpConfig.mcpServers[legacyOrchestratorKey];

      // Check if the new key already exists
      if (!mcpConfig.mcpServers[orchestratorKey]) {
        // Preserve custom configuration from legacy key if it differs from defaults
        const hasCustomConfig =
          legacyConfig.disabled === true ||
          legacyConfig.env !== undefined ||
          (Array.isArray(legacyConfig.args) && !legacyOrchestratorArgs.has(legacyConfig.args[0]));

        if (hasCustomConfig) {
          // Preserve custom settings but update the args to new path
          mcpConfig.mcpServers[orchestratorKey] = {
            ...legacyConfig,
            args: orchestratorArgs
          };
          console.log('üóëÔ∏è Removed legacy orchestrator entry and preserved custom configuration');
        } else {
          // Use default config
          mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
          console.log('üóëÔ∏è Removed legacy orchestrator entry');
        }
      } else {
        // New key already exists, just remove legacy
        console.log('üóëÔ∏è Removed legacy orchestrator entry (new entry already exists)');
      }

      delete mcpConfig.mcpServers[legacyOrchestratorKey];
    }

    if (!mcpConfig.mcpServers[orchestratorKey]) {
      mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
      console.log('‚úÖ Added Agilai orchestrator MCP server');
    } else if (!mcpConfig.mcpServers[legacyOrchestratorKey]) {
      // Ensure orchestrator is enabled during re-init (user may have disabled it)
      const existing = mcpConfig.mcpServers[orchestratorKey];
      existing.disabled = false;
      existing.command = 'node';

      // Check if we need to update args to new format
      const isLegacyPath =
        !Array.isArray(existing.args) ||
        existing.args.length === 0 ||
        (existing.args.length === 1 && legacyOrchestratorArgs.has(existing.args[0])) ||
        (existing.args.length === 2 && existing.args[0] === '-e');

      const needsUpdate = isLegacyPath || (existing.args.length === 1 && existing.args[0] !== orchestratorArgs[0]);

      if (needsUpdate) {
        existing.args = [...orchestratorArgs];
        console.log('‚úÖ Updated Agilai MCP server to latest path');
      }
    }

    const promptYesNo = async (question) => {
      if (!process.stdout.isTTY) {
        return false;
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question} (y/N): `, (answer) => {
          cleanup();
          const normalized = (answer || '').trim().toLowerCase();
          resolve(normalized === 'y' || normalized === 'yes');
        });
      });
    };

    const promptInput = async (question) => {
      if (!process.stdout.isTTY) {
        return '';
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question}: `, (answer) => {
          cleanup();
          resolve((answer || '').trim());
        });
      });
    };

    const optionalServerPromptsNeeded = OPTIONAL_MCP_SERVERS.filter(
      ({ id }) => !mcpConfig.mcpServers[id],
    );

    let selectedServerIds = [];

    if (optionalServerPromptsNeeded.length > 0) {
      if (process.stdout.isTTY) {
        // Use interactive multi-select
        console.log('\nüì¶ Configure MCP servers for your project:\n');
        selectedServerIds = await promptForMcpServers();

        if (selectedServerIds.length === 0) {
          console.log('‚è≠Ô∏è No MCP servers selected - you can add them later via .mcp.json');
        }
      } else {
        console.log(
          '‚ÑπÔ∏è Optional MCP servers detected, but prompts are skipped in non-interactive mode.',
        );
      }
    }

    // Configure selected servers
    for (const serverId of selectedServerIds) {
      const optional = OPTIONAL_MCP_SERVERS.find(s => s.id === serverId);
      if (!optional || mcpConfig.mcpServers[optional.id]) {
        continue;
      }

      const serverConfig = { ...optional.config };

      // Prompt for environment variables if needed
      if (optional.needsEnvPrompt && optional.envKey && optional.envPrompt) {
        try {
          // Check if env var already exists in system environment
          const existingValue = process.env[optional.envKey];
          if (existingValue) {
            console.log(`‚ÑπÔ∏è  Using ${optional.envKey} from system environment`);
            serverConfig.env = serverConfig.env || {};
            serverConfig.env[optional.envKey] = existingValue;
          } else {
            const envValue = await promptInput(optional.envPrompt);
            if (envValue) {
              serverConfig.env = serverConfig.env || {};
              serverConfig.env[optional.envKey] = envValue;
              console.log(`‚úÖ Added ${optional.envKey} to ${optional.label} configuration`);
            } else {
              console.log(`‚ö†Ô∏è Skipping ${optional.envKey} - you can add it manually to .mcp.json later`);
            }
          }
        } catch (error) {
          console.warn(
            `‚ö†Ô∏è Failed to prompt for ${optional.envKey}: ${error.message || error}`,
          );
        }
      }

      mcpConfig.mcpServers[optional.id] = serverConfig;
      console.log(`‚úÖ Added MCP server: ${optional.label}`);
    }

    fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2) + '\n');
    console.log(
      hadExistingMcpConfig
        ? '‚úÖ Updated MCP configuration with selected servers'
        : '‚úÖ Created MCP configuration',
    );

    // Create BMAD-compliant directory structure
    const directories = [
      'docs',              // Root for all documentation
      'docs/prd',          // Sharded PRD (created by PO)
      'docs/architecture', // Sharded architecture (created by PO)
      'docs/stories',      // User stories (created by SM)
      'docs/qa',           // QA assessments and gates
      'docs/qa/assessments',
      'docs/qa/gates',
    ];

    for (const dir of directories) {
      const dirPath = path.join(projectRoot, dir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }
    }

    console.log('‚úÖ Created BMAD directory structure');
    console.log('   üìÅ docs/               (agent-generated documents)');
    console.log('   üìÅ docs/prd/           (sharded PRD epics)');
    console.log('   üìÅ docs/architecture/  (sharded architecture)');
    console.log('   üìÅ docs/stories/       (user stories)');
    console.log('   üìÅ docs/qa/            (QA assessments & gates)');

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      agilai: 'agilai start',
      codex: 'agilai codex',
      'agilai:codex': 'agilai codex',
      'agilai:claude': 'agilai chat',
      'agilai:opencode': 'agilai opencode',
      'agilai:build': 'agilai build',
    };

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('‚úÖ Added npm scripts to package.json');
    }

    // Add agilai as a dependency
    const desiredDependencyVersion = `^${currentVersion}`;
    const existingDependencyVersion =
      packageJson.dependencies && packageJson.dependencies.agilai;
    const needsDependencyUpdate = existingDependencyVersion !== desiredDependencyVersion;

    if (needsDependencyUpdate) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies.agilai = desiredDependencyVersion;
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log(`‚úÖ Ensured agilai@${desiredDependencyVersion} is listed in dependencies`);
    }

    // Only create components.json if shadcn MCP server is enabled
    const shadcnEnabled = mcpConfig.mcpServers['shadcn-ui'] && !mcpConfig.mcpServers['shadcn-ui'].disabled;
    if (shadcnEnabled) {
      const componentsPath = path.join(projectRoot, 'components.json');

      // Auto-detect project configuration for smart defaults
      const detectProjectConfig = () => {
        const config = {
          cssPath: 'app/globals.css',
          tailwindConfig: 'tailwind.config.ts',
          useTsx: true,
          useRsc: true,
        };

        // Detect CSS location (common Next.js paths)
        const cssCandidates = [
          'app/globals.css',
          'src/app/globals.css',
          'styles/globals.css',
          'src/styles/globals.css',
        ];
        for (const candidate of cssCandidates) {
          if (fs.existsSync(path.join(projectRoot, candidate))) {
            config.cssPath = candidate;
            break;
          }
        }

        // Detect Tailwind config variant (.ts vs .js)
        if (fs.existsSync(path.join(projectRoot, 'tailwind.config.js'))) {
          config.tailwindConfig = 'tailwind.config.js';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.cjs'))) {
          config.tailwindConfig = 'tailwind.config.cjs';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.mjs'))) {
          config.tailwindConfig = 'tailwind.config.mjs';
        }
        // Default to .ts if nothing found (assume TypeScript project)

        // Detect TypeScript usage
        const hasTsConfig = fs.existsSync(path.join(projectRoot, 'tsconfig.json'));
        const hasTypeScriptDep = fs.existsSync(packagePath) &&
          (() => {
            try {
              const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
              return (pkg.dependencies && pkg.dependencies.typescript) ||
                     (pkg.devDependencies && pkg.devDependencies.typescript);
            } catch {
              return false;
            }
          })();
        config.useTsx = hasTsConfig || hasTypeScriptDep;

        // Detect Next.js App Router vs Pages Router for RSC
        const hasAppDir = fs.existsSync(path.join(projectRoot, 'app')) ||
                         fs.existsSync(path.join(projectRoot, 'src/app'));
        const hasPagesDir = fs.existsSync(path.join(projectRoot, 'pages')) ||
                           fs.existsSync(path.join(projectRoot, 'src/pages'));
        config.useRsc = hasAppDir || !hasPagesDir; // Default to RSC unless Pages Router is clearly used

        return config;
      };

      // Validate shadcn prerequisites
      const validateShadcnPrerequisites = () => {
        const warnings = [];

        try {
          const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
          const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };

          // Check for Next.js (shadcn primarily targets Next.js)
          if (!allDeps.next && !allDeps.react) {
            warnings.push('Neither Next.js nor React detected. shadcn components require React.');
          }

          // Check for Tailwind CSS
          if (!allDeps.tailwindcss) {
            warnings.push('Tailwind CSS not detected. shadcn components require Tailwind CSS.');
          }
        } catch {
          // If we can't read package.json, skip validation (it was just created)
        }

        return warnings;
      };

      const detectedConfig = detectProjectConfig();
      const validationWarnings = validateShadcnPrerequisites();

      // Show validation warnings if any
      if (validationWarnings.length > 0) {
        console.warn('\n‚ö†Ô∏è shadcn prerequisites check:');
        for (const warning of validationWarnings) {
          console.warn(`   ‚Ä¢ ${warning}`);
        }
        console.warn('   You may need to install these dependencies for shadcn to work properly.\n');
      }

      const shadcnConfig = {
        $schema: 'https://ui.shadcn.com/schema.json',
        style: 'new-york',
        rsc: detectedConfig.useRsc,
        tsx: detectedConfig.useTsx,
        tailwind: {
          config: detectedConfig.tailwindConfig,
          css: detectedConfig.cssPath,
          baseColor: 'zinc',
          cssVariables: true,
        },
        aliases: {
          components: '@/components',
          utils: '@/lib/utils',
        },
        registries: {
          '@originui': 'https://originui.com/r/components.json',
          '@aceternity': 'https://aceternity.com/r/components.json',
          '@magicui': 'https://magicui.design/r/components.json',
        },
      };

      if (!fs.existsSync(componentsPath)) {
        fs.writeFileSync(componentsPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
        console.log('‚úÖ Created shadcn components.json (New York preset)');
        if (detectedConfig.cssPath !== 'app/globals.css' ||
            detectedConfig.tailwindConfig !== 'tailwind.config.ts') {
          console.log(`   üìç Detected paths: ${detectedConfig.cssPath}, ${detectedConfig.tailwindConfig}`);
        }
      } else {
        console.warn('‚ö†Ô∏è components.json already exists. Leaving the current shadcn configuration untouched.');
      }
    } else {
      console.log('‚ÑπÔ∏è Skipped shadcn components.json creation (shadcn MCP server disabled).');
    }

    // Create README.md with BMAD workflow guidance
    const readmePath = path.join(projectRoot, 'README.md');
    const readmeContent = `# ${projectName}

Welcome to your Agilai project! This project follows the **BMAD-METHOD‚Ñ¢** (Breakthrough Method of Agile AI-driven Development) - a universal AI agent framework that orchestrates specialized AI agents through structured workflows.

## üöÄ Quick Start

### 1. Install Dependencies
\`\`\`bash
npm install
\`\`\`

### 2. Start Development
\`\`\`bash
# Launch Codex CLI for interactive development
npm run agilai:codex

# Or use Claude chat
npm run agilai:claude
\`\`\`

## üìÅ Project Structure

\`\`\`
${projectName}/
‚îú‚îÄ‚îÄ docs/                    # Generated documentation
‚îÇ   ‚îú‚îÄ‚îÄ prd/                # Product requirements (sharded by PO agent)
‚îÇ   ‚îú‚îÄ‚îÄ architecture/       # System architecture (sharded by PO agent)
‚îÇ   ‚îú‚îÄ‚îÄ stories/            # User stories (created by SM agent)
‚îÇ   ‚îî‚îÄ‚îÄ qa/                 # QA assessments and gates
‚îÇ       ‚îú‚îÄ‚îÄ assessments/
‚îÇ       ‚îî‚îÄ‚îÄ gates/
‚îú‚îÄ‚îÄ .agilai/                # Agilai metadata
‚îî‚îÄ‚îÄ .mcp.json               # MCP server configuration
\`\`\`

## üéØ BMAD Workflow

The BMAD methodology follows a structured three-phase workflow:

### Phase 1: Planning (Web UI Recommended)
Use BMAD agents in web-based AI platforms (Gemini, ChatGPT) for comprehensive planning:

1. **Analyst Agent** ‚Üí Creates project brief and market research
2. **PM Agent** ‚Üí Generates \`docs/prd.md\` (Product Requirements Document)
3. **Architect Agent** ‚Üí Creates \`docs/architecture.md\` (System Architecture)
4. **UX Expert Agent** (optional) ‚Üí Frontend specifications
5. **PO Agent** ‚Üí Validates and "shards" documents into subdirectories

### Phase 2: Transition to IDE
Copy generated documents to your project:
- \`docs/prd.md\` ‚Üí sharded into \`docs/prd/epic-*.md\`
- \`docs/architecture.md\` ‚Üí sharded into \`docs/architecture/\`

### Phase 3: Development (IDE)
Use agents in your IDE (VS Code, Cursor, Claude Code) for implementation:

1. **Scrum Master (SM)** ‚Üí Creates detailed stories in \`docs/stories/\`
2. **Dev Agent** ‚Üí Implements features following architecture
3. **QA Agent** ‚Üí Reviews and validates code quality
4. **Repeat** until epic is complete

## ü§ñ Available Agents

BMAD provides specialized agents for different tasks:

- **Analyst**: Market research, requirements gathering, brainstorming
- **PM (Product Manager)**: PRD generation, epic/story breakdown
- **Architect**: Technical architecture, design decisions
- **UX Expert**: Frontend specs, UI/UX design
- **PO (Product Owner)**: Validation, document sharding, alignment
- **SM (Scrum Master)**: Story creation, sprint planning
- **Dev**: Code implementation, feature development
- **QA**: Code review, testing, quality gates

## üìù How Documents Are Generated

**Important**: You don't manually fill out templates! BMAD agents generate all documentation using:

- **YAML Templates** (in \`agilai-core/templates/\`): Define document structure
- **Agent Intelligence**: Agents use these templates to create tailored docs
- **MCP Tools**: Model Context Protocol enables agents to create/modify files

### Example Agent Commands

\`\`\`bash
# In IDE with Agilai agent active:
"Use PM agent to create a PRD for user authentication feature"
"Use Architect agent to design the database schema"
"Use SM agent to create stories for Epic 1"
\`\`\`

## üõ†Ô∏è Available Commands

\`\`\`bash
# Core Commands
npm run agilai          # Start Agilai orchestrator
npm run codex           # Launch Codex CLI
npm run agilai:codex    # Same as above
npm run agilai:claude   # Launch Claude chat
npm run agilai:opencode # Open code interface
npm run agilai:build    # Build Agilai bundles

# Build & Development
npm run build           # Build all agents and bundles
npm run build:agents    # Build agent bundles only
npm run build:mcp       # Build MCP server

# Quality
npm run lint            # Run linter
npm run format          # Format code
npm run test            # Run tests
\`\`\`

## üîß Configuration

### MCP Server Configuration
Your MCP servers are configured in \`.mcp.json\`. To modify:
\`\`\`bash
npx agilai init  # Re-run to update MCP configuration
\`\`\`

### LLM Provider Configuration
Set your preferred LLM provider via environment variables:
\`\`\`bash
# Claude (Anthropic)
export ANTHROPIC_API_KEY="your-key"

# GLM (ZhipuAI)
export GLM_API_KEY="your-key"
export GLM_BASE_URL="https://open.bigmodel.cn/api/paas/v4"

# OpenAI
export OPENAI_API_KEY="your-key"

# Gemini
export GEMINI_API_KEY="your-key"
\`\`\`

## üìö Documentation & Resources

- **BMAD Methodology**: [Core Architecture](https://github.com/bacoco/agilai)
- **User Guide**: Complete workflow walkthrough
- **Expansion Packs**: Domain-specific extensions (game dev, creative writing, etc.)
- **Community**: [Discord](https://discord.gg/agilai) for support and discussions

## üéì Learning Path

### New to BMAD?
1. Read the [BMAD User Guide](https://github.com/bacoco/agilai/blob/main/docs/user-guide.md)
2. Try the [Quick Start Tutorial](https://github.com/bacoco/agilai/blob/main/docs/quickstart.md)
3. Explore [Example Projects](https://github.com/bacoco/agilai/tree/main/examples)

### Next Steps
1. ‚úÖ Run \`npm install\` to install dependencies
2. üéØ Use **PM Agent** to create your first PRD
3. üèóÔ∏è Use **Architect Agent** to design your system
4. üíª Use **Dev Agent** to start building!

---

**Powered by Agilai** | BMAD-METHOD‚Ñ¢ Framework
`;

    if (!fs.existsSync(readmePath)) {
      fs.writeFileSync(readmePath, readmeContent);
      console.log('‚úÖ Created README.md with BMAD workflow guidance');
    } else {
      console.warn('‚ö†Ô∏è README.md already exists. Leaving existing content untouched.');
    }

    // Create .agilai/project.json metadata (.agilai directory already created earlier)
    const projectMetadataPath = path.join(projectRoot, '.agilai', 'project.json');
    const projectMetadata = {
      name: projectName,
      version: '1.0.0',
      agilaiVersion: currentVersion,
      createdAt: new Date().toISOString(),
      config: {
        mcpServers: Object.keys(mcpConfig.mcpServers || {}).filter(
          (key) => !mcpConfig.mcpServers[key].disabled,
        ),
      },
    };

    if (!fs.existsSync(projectMetadataPath)) {
      fs.writeFileSync(projectMetadataPath, JSON.stringify(projectMetadata, null, 2) + '\n');
      console.log('‚úÖ Created .agilai/project.json metadata');
    }

    console.log(`
‚ú® Agilai initialized successfully in: ${projectName}/

üìã Created Structure:
   ‚úì README.md - BMAD workflow guide
   ‚úì docs/ - Documentation directory with BMAD structure
   ‚úì .agilai/ - Project metadata
   ‚úì .mcp.json - MCP server configuration

üéØ BMAD Workflow Quick Start:

  Phase 1: Planning (Web UI Recommended)
  ----------------------------------------
  1. Use PM Agent to create PRD ‚Üí docs/prd.md
  2. Use Architect Agent to design system ‚Üí docs/architecture.md
  3. Use PO Agent to validate and shard documents

  Phase 2: Transition to IDE
  ---------------------------
  4. Copy generated docs to your project
  5. PO Agent shards into subdirectories

  Phase 3: Development (IDE)
  ---------------------------
  6. Use SM Agent to create stories ‚Üí docs/stories/
  7. Use Dev Agent to implement features
  8. Use QA Agent to review and validate

üì¶ Next Steps:

  1. Install dependencies:
     cd ${projectName}
     npm install

  2. Read the README for detailed workflow:
     cat README.md

  3. Start development with your chosen agent:
     npm run agilai:codex    # Codex CLI
     npm run agilai:claude   # Claude chat

  4. Begin with PM Agent to create your PRD:
     "Use PM agent to create a PRD for [your project idea]"

üìö Resources:
   ‚Ä¢ README.md - Full BMAD workflow guide (in ${projectName}/)
   ‚Ä¢ https://github.com/bacoco/agilai - Complete documentation
   ‚Ä¢ Discord: https://discord.gg/agilai - Community support

Happy building with BMAD! üöÄ
`);
  },

  codex: async () => {
    consumeLlmOptionsFromArgs();

    const localInstall = path.join(process.cwd(), 'node_modules', 'agilai');
    const codexScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'agilai-codex')
      : path.join(__dirname, 'agilai-codex');

    if (!fs.existsSync(codexScript)) {
      console.error('‚ùå Agilai not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx agilai init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [codexScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: buildSpawnEnv(),
    });

    child.on('error', (error) => {
      console.error('‚ùå Failed to launch Codex CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  chat: async () => {
    consumeLlmOptionsFromArgs();

    // Check if agilai is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'agilai');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'agilai-claude')
      : path.join(__dirname, 'agilai-claude');

    if (!fs.existsSync(chatScript)) {
      console.error('‚ùå Agilai not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx agilai init && npm install');
      process.exit(1);
    }

    await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });

    // Merge runtime LLM flags with Anthropic-compatible GLM env when active
    const baseEnv = buildSpawnEnv();
    const { env: glmCompatEnv, isGlm } = buildAssistantSpawnEnv();
    const chatEnv = isGlm ? { ...baseEnv, ...glmCompatEnv } : baseEnv;

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: chatEnv,
    });

    child.on('error', (error) => {
      console.error('‚ùå Failed to launch Claude CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  opencode: async () => {
    const { env: opencodeEnv, isGlm } = buildAssistantSpawnEnv();

    if (isGlm) {
      console.log('üåê GLM mode active: routing OpenCode CLI through configured GLM endpoint.');
    }

    const child = spawn('opencode', args, {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: false,
      env: opencodeEnv,
    });

    child.on('error', (error) => {
      console.error('‚ùå Failed to launch OpenCode CLI:', error.message);
      console.error('   Make sure OpenCode is installed and in your PATH.');
      console.error('   Visit: https://github.com/openchatai/opencode for installation instructions');
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  install: async () => {
    console.log('üì¶ Installing Agilai globally...\n');

    const child = spawn('npm', ['install', '-g', 'agilai'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n‚úÖ Agilai installed globally!');
        console.log('You can now use: agilai <command>');
      }
      process.exit(code || 0);
    });
  },

  build: async () => {
    console.log('üî® Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'agilai');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const packagedEntryCandidates = [
      path.join(rootDir, 'dist', 'mcp', 'mcp', 'server.js'),
      path.join(rootDir, 'dist', 'mcp', 'server.js'),
    ];
    const resolvedPackagedEntry = packagedEntryCandidates.find((candidate) =>
      fs.existsSync(candidate),
    );

    if (resolvedPackagedEntry) {
      console.log('‚úÖ MCP server already built and ready!');
      console.log(`   Entry point: ${resolvedPackagedEntry}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        const builtEntry = packagedEntryCandidates.find((candidate) =>
          fs.existsSync(candidate),
        );
        console.log('\n‚úÖ MCP server built successfully!');
        if (builtEntry) {
          console.log(`   Entry point: ${builtEntry}`);
        }
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

const setRuntimeContext = (nextCommand, nextArgs = [], options = {}) => {
  command = nextCommand;
  args = Array.isArray(nextArgs) ? [...nextArgs] : [];
  runtimeOptions = { ...createDefaultRuntimeOptions(), ...(options.runtimeOptions || {}) };
};

const run = (argv = process.argv) => {
  runtimeOptions = createDefaultRuntimeOptions();
  [, , command, ...args] = argv;

  if (!command || command === '--help' || command === '-h') {
    printHelp();
    return Promise.resolve();
  }

  const handler = commands[command];
  if (!handler) {
    console.error(`‚ùå Unknown command: ${command}`);
    console.log('Run "npx agilai help" for usage information.');
    process.exit(1);
  }

  try {
    const result = handler();
    if (result && typeof result.then === 'function') {
      return result.catch((error) => {
        console.error('‚ùå Error:', error.message);
        process.exit(1);
      });
    }

    return Promise.resolve(result);
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
    return Promise.resolve();
  }
};

// Run integrity check only when executed directly (not when imported for testing)
// This ensures the CLI validates package integrity at runtime while allowing
// tests to import and mock functions without triggering validation
if (require.main === module) {
  // Skip integrity check during installation to avoid confusing warnings
  const skipIntegrityCheck = process.argv.includes('start') || process.argv.includes('init');
  if (!skipIntegrityCheck) {
    runIntegrityPreflight(packageRoot, { silentOnMatch: true });
  }

  run().catch((error) => {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  commands,
  determineAssistant,
  parseAssistantFromArgs,
  printHelp,
  run,
  runIntegrityPreflight,
  setRuntimeContext,
};
